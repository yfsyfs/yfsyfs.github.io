<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>ThreadLocal 源码解读 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="缘起【1】中我们已经见识到了在框架代码中大量使用ThreadLocal变量. 遂激发了我想了解ThreadLocal的源码的兴趣.">
<meta name="keywords" content="源码,后端,JDK,并发">
<meta property="og:type" content="article">
<meta property="og:title" content="ThreadLocal 源码解读">
<meta property="og:url" content="http://yoursite.com/2019/06/27/ThreadLocal-源码解读/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="缘起【1】中我们已经见识到了在框架代码中大量使用ThreadLocal变量. 遂激发了我想了解ThreadLocal的源码的兴趣.">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/2019/06/27/ThreadLocal-源码解读/1.png">
<meta property="og:updated_time" content="2019-06-29T13:25:29.346Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ThreadLocal 源码解读">
<meta name="twitter:description" content="缘起【1】中我们已经见识到了在框架代码中大量使用ThreadLocal变量. 遂激发了我想了解ThreadLocal的源码的兴趣.">
<meta name="twitter:image" content="http://yoursite.com/2019/06/27/ThreadLocal-源码解读/1.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-ThreadLocal-源码解读" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/27/ThreadLocal-源码解读/" class="article-date">
  <time datetime="2019-06-27T07:52:15.000Z" itemprop="datePublished">2019-06-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      ThreadLocal 源码解读
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h3><p>【1】中我们已经见识到了在框架代码中大量使用ThreadLocal变量. 遂激发了我想了解ThreadLocal的源码的兴趣.</p>
<a id="more"></a>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>形象的说（虽然源码实现并不是这样）:</p>
<blockquote>
<p>ThreadLocal\<t> 可以视作 Map&lt;Thread, T&gt; </t></p>
</blockquote>
<p>也就是其实ThreadLocal变量使得我们可以实现线程隔离——针对每根线程存储了各自具体的<strong>值</strong>，每根线程各拿各的，就像商场里面的存包柜子一样——既然每根线程拿的东西都不一样，自然就不会存在并发问题. 所以线程隔离也是实现无锁的一种方式（都不存在竞争，要锁干什么呢?）.  线程终止之后，这个<strong>值</strong>会被gc掉.</p>
<blockquote>
<p>ps: 实现线程安全的手段有 “有锁”、”无锁”， 其中有锁就是同步，无锁有 线程封闭+不变性两种，其中线程封闭又分为ad hoc、栈限制、和本文的ThreadLocal 这三种. 具体可以参见【2】,ThreadLocal是线程封闭较好的实现方式.</p>
</blockquote>
<p>在分析源码之前，列举一些ThreadLocal的应用场景</p>
<h4 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h4><p>让每根线程拥有自己的数据库连接，即</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHolder = <span class="keyword">new</span> ThreadLocal&lt;Connection&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(DB_URL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> connectionHolder.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>其实JDBC规范是没有要求java.sql.Connection 接口的实现是线程安全的</strong>. 就是因为可以使用上述ThreadLocal的手段隔离各个线程. 所以没必要线程安全.</p>
<h4 id="频繁的分配写缓存（buffer）"><a href="#频繁的分配写缓存（buffer）" class="headerlink" title="频繁的分配写缓存（buffer）"></a>频繁的分配写缓存（buffer）</h4><p>例如一种写操作很频繁，而每次都要获取buffer进行写操作.  此时就可以考虑将buffer放进ThreadLocal中去. </p>
<p>如果使用共享全局变量的话，显然是需要使用锁进行同步的——不能让两次写操作并发使用该共享buffer. 但是如果使用ThreadLocal的话，就不存在竞争，也就不需要加锁. 效率较高. 但是比较尴尬的事情是——除非分配的极为频繁或者一次分配的代价极为高昂. 来一次写操作就分配一次或许更好. 也就是在写操作并不是那么的频繁的情况下ThreadLocal并不能带来多少性能优势.</p>
<h4 id="应用程序框架"><a href="#应用程序框架" class="headerlink" title="应用程序框架"></a>应用程序框架</h4><p>这个其实用的最为广泛——将上下文（例如运行的参数）缓存到一个静态的ThreadLocal中去, 则框架代码想知道当前线程中的信息的时候，就可以从ThreadLocal中获取. ThreadLocal的缺点就是容易使得业务代码和框架代码耦合，即框架的侵入性会提高.</p>
<p>列举了上面的应用场景，我们开始分析ThreadLocal的源码</p>
<p>首先要说明一下ThreadLocal的简单用法</p>
<p>假设 我们新建了2个ThreadLocal变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHolder</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;User&gt; threadLocal_1 = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Client&gt; threadLocal_2 = <span class="keyword">new</span> ThreadLocal&lt;&gt;();   </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">set_1</span><span class="params">(Object v)</span> </span>&#123;</span><br><span class="line">        threadLocal_1.set(v);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">set_2</span><span class="params">(Object v)</span> </span>&#123;</span><br><span class="line">        threadLocal_2.set(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并且在三根线程中使用他们</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thread-1中</span></span><br><span class="line">ThreadLocalHolder.set_1(user_1);</span><br><span class="line">ThreadLocalHolder.set_2(client_1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// thread-2中</span></span><br><span class="line">ThreadLocalHolder.set_1(user_2);</span><br><span class="line">ThreadLocalHolder.set_2(client_2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// thread-3中</span></span><br><span class="line">ThreadLocalHolder.set_2(client_3);</span><br></pre></td></tr></table></figure>
<p>则最终，会是下图这个样子</p>
<img src="/2019/06/27/ThreadLocal-源码解读/1.png">
<p>​                                                                                                图1</p>
<p>为什么呢?</p>
<p>我们来看看ThreadLocal.set方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​                                                                                        源码1</p>
<p>第二行首先得到当前线程（currentThread是native方法，在此不做过多讨论），第三行的源码如下</p>
<p>ThreadLocal.getMap</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​                                                                                源码2</p>
<p>可见，我们其实是获取当前线程的一个名为threadLocals的属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p>​                                                                                    源码3</p>
<p>注意，这个属性是默认访问权限的, 也就是不准备暴露给别的包下的类（当然，除非你在项目中也新建一个java.lang的包）,所幸， ThreadLocal和Thread都是java.lang包下的, 所以ThreadLocal中可以访问到该Thread的属性. 回到源码1,就知道了，我们其实是对Thread的这个threadLocals属性进行操作，而这个threadLocals其实是一个类似Map的东西——ThreadLocalMap（即图1中的代表每根线程的圆角框框里面的矩形）， 我们先不管这个东西到底是什么，我们目前就知道我们使用ThreadLocal进行set的时候其实是对这个map进行set（以ThreadLocal变量本身为key），后面我们会再细讲这个ThreadLocalMap的api源码.</p>
<p>不过，在此之前，我们先对ThreadLocalMap有一个大概的印象——来自ThreadLocalMap的官方注释</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap is a customized hash map suitable only for</span><br><span class="line">maintaining thread local values. No operations are exported</span><br><span class="line">outside of the ThreadLocal class. The class is package private to</span><br><span class="line">allow declaration of fields in class Thread.  To help deal with</span><br><span class="line">very large and long-lived usages, the hash table entries use</span><br><span class="line">WeakReferences for keys.</span><br></pre></td></tr></table></figure>
<p>即ThreadLocalMap是仅仅Thread内部用的一个Map（事实上，ThreadLocalMap就是ThreadLocal的私有内部类）——它的实现和java.util.HashMap一样也是通过哈希表（其实就是一个Entry数组,但是ThreadLocal的Entry是java.lang.ThreadLocal.ThreadLocalMap.Entry，和java.util.HashMap的java.util.Map.Entry&lt;K, V&gt; 不同）实现的，但是java.util.HashMap处理哈希冲突的方法是链表，而这里的ThreadLocalMap处理哈希冲突的是方法是开发地址法之线性探测. 之所以采用这个，完全是因为ThreadLocalMap对它的哈希算法的自信, 这个后面会再细说. 而且为了处理长时间存在的线程（例如，线程本身就是从线程池中获取的，线程将长久存在而不消失），这里的哈希表的元素——Entry使用的是弱引用（即Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt;）. 这个后面会细说.</p>
<p>同理， ThreadLocal.get() 方法源码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​                                                                                    源码4</p>
<p>发现没有，也是一样的套路——都是先获取当前线程，然后找到这根线程中的ThreadLocalMap属性，然后直接以ThreadLocal变量为key，从该map中获取value. 并且返回。这就好像是一根线程Thread中执行ThreadLocal变量.get()的话，ThreadLocal变量会告诉当前线程Thread——“嘿，伙计，其实你要的东西就藏在你自己身体里（即Thread中的ThreadLocalMap属性），你只需要拿我当key，去你自己体内的这个ThreadLocalMap中去找就行了”. 换言之， ThreadLocal本身不存储数据，数据都是在各自Thread中（的ThreadLocalMap属性）维护的.</p>
<p> 如果map属性是null的话（Thread类中对此属性的初始化就是null），则调用源码4的第12行，跟进去</p>
<p>ThreadLocal.setInitialValue</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T value = initialValue();</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​                                                                                        源码5</p>
<p>套路依旧——获取当前线程，获取线程的ThreadLocalMap属性，如果是null的话（第一次就是null），就跟进源码5的第8行. 但是在跟进之前，我们来看看第2行，这里挺有意思，这里是获取ThreadLocal的初始化值的. 跟进去</p>
<p>ThreadLocal.initialValue</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​                                                                                    源码6</p>
<p>注意，貌似是返回null，但是这个方法是protected的，所以如果使用ThreadLocal的时候Override了这个方法的话，返回的就不是null了.  也就是经常我们能看到的如下用法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;XXX&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">protected</span> Object <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> ZZZ; <span class="comment">// 该ThreadLocal的初始化值是ZZZ</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
<p>好了，经过此小插曲，我们来到源码5的第八行</p>
<p>ThreadLocal.createMap</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​                                                                                源码7</p>
<p>跟进如下构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; <span class="comment">// firstValue就是上述initialValue的返回值</span></span><br><span class="line">            table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY]; <span class="comment">// 初始化table（一个Entry数组）,初始化容量是16</span></span><br><span class="line">            <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>); <span class="comment">// 计算firstValue就是上述initialValue的返回值的哈希值</span></span><br><span class="line">            table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">            size = <span class="number">1</span>; <span class="comment">// table包含的初始entry数量是1</span></span><br><span class="line">            setThreshold(INITIAL_CAPACITY); <span class="comment">// 常量INITIAL_CAPACITY=16</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>​                                                                     源码8</p>
<p>这段代码有一些要说的. 从简单的说起，首先就是第6行——setThreshold，顾名思义就是设置table数组的阈值（因为哈希表的扩容是基操）,扩容操作源码如下</p>
<p>ThreadLocalMap.setThreshold</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setThreshold</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">            threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>​                                                                                    源码9</p>
<p>即阈值是table数组的容量的2/3, 其中table是ThreadLocal的属性.  下面来看源码8的第三行. 其实这种&amp; 运算本质就是对table数组的长度取模, 这种操作在分析HashMap的源码的时候已经说过了（详见【4】的源码3的哈希1）. 这里要说的是源码8第三行的threadLocalHashCode，它是ThreadLocal的属性——threadLocalHashCode</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br></pre></td></tr></table></figure>
<p>​                                                                        源码10</p>
<p>注意，它的初始化是通过以下函数进行的</p>
<p>ThreadLocal.nextHashCode</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode =</span><br><span class="line">        <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>; <span class="comment">/// 一个神奇的数（1640531527）——实现完美哈希</span></span><br></pre></td></tr></table></figure>
<p>​                                                                            源码11</p>
<p>因为源码10 的threadLocalHashCode不是静态属性，所以源码11的顺序可以随意. 这是java的基础知识. 就不多说了, 而且源码10一旦获取到了threadLocalHashCode之后，每次调用ThreadLocal实例的threadLocalHashCode属性都不会变的.</p>
<p>其中源码11的第二行就实现了完美哈希.  所谓完美哈希指的是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hashCode</span><span class="params">(Integer length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hashCode = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            hashCode = i*HASH_INCREMENT+HASH_INCREMENT;<span class="comment">//每次递增HASH_INCREMENT</span></span><br><span class="line">            System.out.print(hashCode &amp; (length-<span class="number">1</span>));<span class="comment">//求散列下标，算法公式</span></span><br><span class="line">            System.out.print(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        hashCode(<span class="number">16</span>);<span class="comment">//初始化16</span></span><br><span class="line">        hashCode(<span class="number">32</span>);<span class="comment">//后续2倍扩容</span></span><br><span class="line">        hashCode(<span class="number">64</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">7 14 5 12 3 10 1 8 15 6 13 4 11 2 9 0 --》Entry[]初始化容量为16时，元素完美散列  </span></span><br><span class="line"><span class="comment">7 14 21 28 3 10 17 24 31 6 13 20 27 2 9 16 23 30 5 12 19 26 1 8 15 22 29 4 11 18 25 0--》Entry[]容量扩容2倍=32时，元素完美散列</span></span><br><span class="line"><span class="comment">7 14 21 28 35 42 49 56 63 6 13 20 27 34 41 48 55 62 5 12 19 26 33 40 47 54 61 4 11 18 25 32 39 46 53 60 3 10 17 24 31 38 45 52 59 2 9 16 23 30 37 44 51 58 1 8 15 22 29 36 43 50 57 0 --》Entry[]容量扩容2倍=64时，元素完美散列</span></span><br><span class="line"><span class="comment">此算法(即源码11中的nextHashCode方法)在长度为2的N次方的数组上，确实可以完美散列（至于机制，涉及较多的数学理论，这里不展开了）</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>正因为如此，ThreadLocalMap的table属性的官方注释是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The table, resized as necessary. table.length MUST always be a power of two.</span><br></pre></td></tr></table></figure>
<p>即table的长度（注意，table的长度length和ThreadLocalMap另一个属性size——The number of entries in the table. 不是同一个值，并且显然有size &lt;= length）</p>
<p>好了，我们再次回到源码8的第四行，Entry这个类的源码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>​                                                                                    源码12</p>
<p>注意，Entry是弱引用? 关于java中的四大引用详见【3】. 为什么要使用弱引用呢?  弱引用的一大特点就是如果有强引用对象引用着对象（一块堆内存），则GC的时候宁可抛OOM也是不会GC的，但是如果一个对象只被一个弱引用对象引用着的话，一旦遇到GC的话，就会被GC。为了解释为什么必须是弱引用，如果使用的Entry是ThreadLocal变量的强引用，例如Entry的代码这样写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>  </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line">    </span><br><span class="line">    		ThreadLocal&lt;?&gt; t; <span class="comment">// 持有ThreadLocal的强引用</span></span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">this</span>.t = k;</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>我们想想，如果使用了一个ThreadLocal变量t（其实t是ThreadLocal的引用对象，只是一个引用而已）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;?&gt; t = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>但是事后觉得不需要了，就直接将该ThreadLocal变量的引用置空</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p>那么你觉得下次GC的时候，原本t指向的堆内存会被GC吗?  显然不会，因为如果线程长时间存在（例如它是从线程池中获取的线程，线程不停止，ThreadLocalMap不释放的，何以为证? 我们看看Thread的源码就知道了</p>
<p>Thread.exit()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (group != <span class="keyword">null</span>) &#123;</span><br><span class="line">            group.threadTerminated(<span class="keyword">this</span>);</span><br><span class="line">            group = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Aggressively null out all reference fields: see bug 4006245 */</span></span><br><span class="line">        target = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">/* Speed the release of some of these resources */</span></span><br><span class="line">        threadLocals = <span class="keyword">null</span>; <span class="comment">// 释放ThreadLocalMap</span></span><br><span class="line">        inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">        inheritedAccessControlContext = <span class="keyword">null</span>;</span><br><span class="line">        blocker = <span class="keyword">null</span>;</span><br><span class="line">        uncaughtExceptionHandler = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​                                                                                源码13</p>
<p>源码13的第九行足以说明Thread和它的ThreadLocalMap同岁齐辉~</p>
<p>），则它的ThreadLocalMap属性就会长时间存在，则ThreadLocalMap的Entry数组,  即table属性就会长时间存在——table强引用着这个ThreadLocal堆内存呢! 导致即便你在应用程序中显式置空了ThreadLocal变量——t=null, 但是t指向的堆内存依旧不会被GC。这就是堆内存泄漏了.  为了解决这个问题，使用了弱引用对象——Entry实例去引用ThreadLocal堆内存. 一旦置t为空（null），则因为没有强引用t罩着了，唯余Entry这个弱引用，则下次GC的时候，ThreadLocal堆内存就会被回收.  其实这种思想在【5】（WeakHashMap）中也用到了. 都是为了解决这种问题的，或者说，弱引用就是为此而生的.</p>
<p>那么，如果使用了弱引用了，就万事大吉了吗? 非也非也~ 还是存在内存泄漏问题. </p>
<p>WTF？ 我没听错吧? 刚刚说了半天，使用弱引用解决的问题不就是为了解决内存泄漏问题吗? 怎么还有? 事实是，ThreadLocal变量对应的堆内存的内存泄漏问题是被解决了，ThreadLocal只是Entry的键，但是Entry的值的内存泄漏问题又蹦出来了.  怎么讲? 因为Entry的键（ThreadLocal）只是弱引用，一旦显式t=null置空之后，很可能在某次GC中会回收，则此Entry的键变成null, 但是应用程序是不可能利用null进行查询的, 但是此Entry的value会不会被GC掉呢? 同之前的道理也是不会的，因为Thread长时间存在–&gt;ThreadLocalMap长时间存在–&gt;table数组长时间存在–&gt;强引用着Entry元素（的value）, 这就造成了Entry的值的内存泄漏（之前通过弱引用解决的是Entry键的内存泄漏问题，现在又来了值的内存泄漏问题）. 怎么解决呢? JVM团队当然注意到了这个问题，Josh Bloch 和 Doug Lea两位大神（ThreadLocal的作者）的解决办法是：每次对ThreadLocalMap进行get/set/remove 的时候，对其table数组中非空但是键空的Entry（即table[i]!=null &amp;&amp; table[i].get()==null, 注意，get不是Entry自己的方法，而是Entry的父类——java.lang.ref.Reference<t>的get方法, 根据源码12就知道table[i]（即Entry实例）的get方法返回的就是k, 即键），我们称这种Entry 为脏项（网上也都这么叫），进行清除. </t></p>
<p><strong>再次强调</strong>：脏项是怎么形成的? 就是通过直接去除ThreadLocal变量的强引用，导致在各个线程的ThreadLocalMap中的table数组（即哈希表）中相应的Entry的键被回收（变null），但是值没有被回收，即值所占据的堆内存空间出现了内存泄漏. 这种情况就叫做脏项.</p>
<p>ps： 网上说的很多ThreadLocal内存泄漏问题其实就是这种脏项的出现，但是如我们所见，JVM团队已经出手尽可能的解决这个问题了.</p>
<p>下面就来细看源码，这两位大神是如何实现的，Sorry， ThreadLocal讲了半天，其实是在了解它的背景（我的一贯认知就是，一个东西的历史背景其实往往比它本身更重要，很多时候，你看不懂一个东西，有时候未必是你的单纯知识积累不够，而是你不了解它诞生的历史背景， 所以前面的讲解其实一样重要）.</p>
<p>回到ThreadLocal的set方法. 即源码1，我们主要看源码1的第五行. 跟进去</p>
<p>java.lang.ThreadLocal.ThreadLocalMap.set(ThreadLocal&lt;?&gt;, Object)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We don't use a fast path as with get() because it is at</span></span><br><span class="line">            <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">            <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">            <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                 e != <span class="keyword">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123; <span class="comment">// 因为哈希的充分，所以其实此for循环走的不多</span></span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (k == key) &#123; <span class="comment">// 如果找到了key（显然不是脏项），则简单覆盖</span></span><br><span class="line">                    e.value = value;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123; <span class="comment">// 遇到了脏项，但是未必后面就不会出现此key（因为完全可能先遇到脏项）, 所以才要进到replaceStaleEntry方法中去而不能简单这里就将脏项赋予key/value，否则如果简单赋予替换掉的话，哈希表中可能出现两个key（一个是这里简单但是错误的替换掉的，另一个就是后面暂时没遇到的），这岂不是糟了?</span></span><br><span class="line">                    replaceStaleEntry(key, value, i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">            <span class="keyword">int</span> sz = ++size;</span><br><span class="line">            <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">                rehash();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>​                                                                            源码14</p>
<p>第12行的for循环显然是在处理哈希冲突. 其中i 是插入的key（即ThreadLocal）本来应该占据的索引. 如果没冲突的话（所谓没冲突就是for循环中一直没有return, 即哈希冲突也只是没有脏项，而且键和ThreadLocal不相等.），直接执行第28行，即table[i]插入该条目. 否则的话，第15行首先取得i处的已被占据的ThreadLocal，然后如果发现与待插入的ThreadLocal是同一个的话（比的是地址，不是equals方法），则第18行简单覆盖了事(即return). 如果发现被占据的是一枚脏项的话（即源码14的第22行），则要做清除脏项的处理——replaceStaleEntry，注意，Stale的意思就是陈旧的，腐烂的，也就是这里说的脏.</p>
<p>处理完脏项之后（这里面的处理一定包含将待插入的键值插入table）, 直接返回. 我们先不细跟replaceStaleEntry方法，只知道此方法的三个入参分别是待插入的键值和本应该插入的索引i（注意，i可能因为table[i]不是脏项但是其键也不等于key而通过nextIndex方法而变化，nextIndex方法仅仅是一个简单的线性探测的方法，说白了就是往后加1, 这里仅仅列出源码而不分析了(后面也有类似的prevIndex方法，和这里类似).</p>
<p>java.lang.ThreadLocal.ThreadLocalMap.nextIndex(int, int)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Increment i modulo len.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>）.  如果for循环中一直没有return的话，也就是哈希冲突一直是”真的”哈希冲突, 即冲突项也不是脏项. 那么就执行源码14的第30行，进行cleanSomeSlots调用，它的入参是table[i]为null的i（因为你来到了这里，只可能是table[i]为null）, 以及当前table数组中的条目（或者叫项）的个数.  注意，之前说的源码14的第23行的replaceStaleEntry里面也是需要调用cleanSomeSlots的，所以打算一起说. 源码14的第30行大概你留个印象说的就是如果table中的真实包含的条目的个数（size）超过了阈值（ThreadLocalMap的threshold属性，在源码8的第六行初始化）并且在table[i]附近没发现脏项的话，则就要进行重哈希. rehash方法后面我们细说.</p>
<p>这里进入本文的重头戏——replaceStaleEntry方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">            Entry e;</span><br><span class="line">            <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">                 (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">                 i = prevIndex(i, len))</span><br><span class="line">                <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">                    slotToExpunge = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">                 (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">                 i = nextIndex(i, len)) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">                <span class="keyword">if</span> (k == key) &#123; <span class="comment">// staleSlot后续有key，则交换</span></span><br><span class="line">                    e.value = value;</span><br><span class="line"></span><br><span class="line">                    tab[i] = tab[staleSlot];</span><br><span class="line">                    tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                        slotToExpunge = i;</span><br><span class="line">                    cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); <span class="comment">// expungeStaleEntry(slotToExpunge)出发，清除脏项</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">                    slotToExpunge = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If key not found, put new entry in stale slot</span></span><br><span class="line">            tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">            tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If there are any other stale entries in run, expunge them</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">                cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>​                                                                        源码15</p>
<p>这里要记得从源码14第23行的入参——key和value就是待插入的键值对（键是一个ThreadLocal强引用），staleSlot是脏项在table数组中的索引（这个位置是在源码14的第23行原本准备插入key、value的，但是现在进到replaceStaleEntry方法中来看看后面是不是有key，因为你总不可能一个哈希表中有两个一样的key吧,源码14的第22行也解释的很清楚为什么需要进到此方法中来了）.  源码15第12行之前，我们使用slotToExpunge保存了<strong>往前寻找</strong>脏项的索引，寻找的方式是只要table项为null的话，就停止寻找，如果不为null的话，看看是不是脏项，如果是的话，更新slotToExpunge，注意哦， slotToExpunge有可能和入参的staleSlot相等哦~ 然后开始进行源码15的第13行——<strong>向后寻找</strong>，寻找的方式也是一样的——如果找到了null的table项的话，就停止. 每考察一项，即源码15的第15行，如果和当前需要插入的键相等的话，则表明哈希表中其实是有这个key的，只是源码14的第22行我们先遇到脏项了而已.  但是这个时候，有的读者可能就会有问题——如果在源码15第16行，即遇到哈希表中的key之前就遇到了null呢? 这是一个问题诶~ 因为这样就会导致源码15的第12行的for循环提前结束，导致的后果就是——我们再也碰不到key了诶~ 但是这种担心是多余的~ 为什么? 因为后面要讲解的cleanSomeSlots中真正起到删除作用的expungeStaleEntry调用中会进行重哈希的，进而不会造成这里说的情况的. 这个expungeStaleEntry方法我们后面会再讲.</p>
<p>回到源码15第17行，即我们发现了key（即e=table[i].get()=key），则将table[i]应该移动到脏项staleSlot的位置处（因为原本table[i]肯定是出于处理哈希碰撞的原因才来到了table[i],现在占着它原本应该占据的table[staleSlot]的元素变成了脏项，则table[i]这个非脏项自然可以回归咯~），所以源码15 的第17~20行就做了这件事情. 然后如果往前找脏项未果的话（即slotToExpunge=staleSlot），则更新slotToExpunge=i（即table[i], 它现在不是已经和之前的table[staleSlot]在源码15 的17~20行交换了么? 所以table[i]变成了脏项，而table[staleSlot]迎接非脏项），其实slotToExpunge这个东西就是下一步马上就要进行的清除脏项的起点索引， 所以如果之前往前找脏项如果找到了的话，则显然这里不能将清除脏项的起点更新为i. 然后源码15 的第24行就开始清除脏项了——start from “expungeStaleEntry(slotToExpunge)”, 这个expungeStaleEntry后面我们马上就讲.  然后就返回了，也就是如果源码15找到了key的话，就交换，然后清理脏项. 然后终止for循环, 返回. </p>
<p>如果寻找的过程中一直没找到key, 但是找到了脏项（即源码15的第28行），并且从staleSlot往前没找到脏项（所以slotToExpunge=staleSlot没变过），则就更新脏项的起点slotToExpunge=i（于是，这是清除脏项的新起点，后面for循环再找到脏项，因为slotToExpunge不再等于staleSlot而不会更新了）.</p>
<p>如果for循环执行完而没有因为找到了key而return的话，则来到了源码15第33行，说明key就是在哈希表中本就不存在，注意，staleSlot在整个replaceStaleEntry过程中是不变的，一直保持入参的样子，  所以直接插入即可，即源码15的33~34行做的事情. 最后， 源码15 的第37行，如果slotToExpunge != staleSlot，表明整个过程中虽然没找到key，但是发现了脏项，则就需要清除脏项.  和源码15的第24行一样，调用的是cleanSomeSlots(expungeStaleEntry(slotToExpunge), len)， 下面我们来细讲这个调用.</p>
<p>首先，来看expungeStaleEntry(slotToExpunge)这个调用. 入参slotToExpunge是脏项的起点. 即table[slotToExpunge] 是脏项. 跟进去</p>
<p>java.lang.ThreadLocal.ThreadLocalMap.expungeStaleEntry(int)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">            tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">            tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">            Entry e;</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">                 (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">                 i = nextIndex(i, len)) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    e.value = <span class="keyword">null</span>;</span><br><span class="line">                    tab[i] = <span class="keyword">null</span>;</span><br><span class="line">                    size--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                        tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                        <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                        <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                            h = nextIndex(h, len);</span><br><span class="line">                        tab[h] = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>​                                                                                源码16</p>
<p>牢记源码16 的入参是一个脏项的索引（其实是源码15决定的脏项的起点——slotToExpunge）. 所以源码16 的第6到第八行做的事情就是”expunge entry at staleSlot”.  注意，这里的清除就体现了前面说的JVM团队解决因为弱引用导致的ThreadLocalMap的Entry值的内存泄漏问题. 因为这里直接去掉了值的强引用（Bytab[staleSlot].value = null）. 并且将整个table[staleSlot]置空了.  </p>
<p>然后要做的事情就是”Rehash until we encounter null”（即expungeStaleEntry不仅仅清除的是一个脏项，它比较热心肠——还将附近的脏项也统统一网打尽了）,源码16 的第17行，如果遇到了脏项的话，则和6~8行一样清除它，如果不是脏项的话，就需要重哈希了. 这里重哈希的方法是，首先计算它理想的位置h（源码16 的第22行），然后如果和当前位置不符的话才进行下面的——将现在的位置tab[i]置空，并且利用开放地址法之线性探测找到新的位置. 注意，重哈希的意义何在? 我至少发现2点，第一点是哈希表进行重哈希利于下一次搜索的速度，这一点属于哈希表的共识，第二点就是为了避免前面讨论过的”有的读者可能就会有问题…”</p>
<p>好了，最后源码16返回的东西就是table[i]=nulll的索引，因为源码16 的for循环中没有提前return的语句啊.</p>
<p>弄懂了expungeStaleEntry，我们回到源码15 的此方法的两处调用，一处是源码15的24行，一处是38行. 这下子我们就知道了expungeStaleEntry(slotToExpunge)作为入参是什么了. 就是从slotToExpunge开始咣咣咣一顿处理（脏项移除，非脏项重哈希）之后为null的table索引.  跟进cleanSomeSlots方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                i = nextIndex(i, len);</span><br><span class="line">                Entry e = tab[i];</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    n = len;</span><br><span class="line">                    removed = <span class="keyword">true</span>;</span><br><span class="line">                    i = expungeStaleEntry(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> removed;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>​                                                                                        源码17</p>
<p>记住，cleanSomeSlots的入参，i是一个table[i]=null的索引i, n是table数组的length. 返回的removed就是如果一旦发生了清除，则就是返回true，否则如果从未发生过清除脏项的话，则返回的就是false. 注意，首先解释一下为什么这里有个 n&gt;&gt;&gt;1, 这是保符号右移.  其实官方的注释也说清楚了</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">This is invoked when either a new element is added, or</span><br><span class="line">another stale one has been expunged.</span><br><span class="line">It performs a logarithmic number of scans, as a balance between no</span><br><span class="line">scanning (fast but retains garbage) and a number of scans</span><br><span class="line">proportional to number of elements, that would find all</span><br><span class="line">garbage but would cause some insertions to take O(n) time.</span><br><span class="line">译文</span><br><span class="line">当新元素被添加时，或者另一个过期元素已被删除时，会调用cleanSomeSlots。该方法会试探性地扫描一些 entry 寻找过期的条目。它执行对数数量的扫描，是一种 基于不扫描（快速但保留垃圾）和 所有元素扫描之间的平衡。</span><br></pre></td></tr></table></figure>
<p>如果发现了脏项table[i]（源码17 的第八行），则置n为table数组的长度（相当于是小时候打游戏的回血续命），标记removed为true（即的确成功的删除了脏项），然后最后调用expungeStaleEntry（这个源码16细说过了），对脏项table[i]以及附近的脏项进行清除， 最后源码17的第11行的i就是一个table[i]为 null（进而不是脏项）的索引.</p>
<p>好了，至此replaceStaleEntry已经分析清楚了. 我们回到源码14第23 行，即如果发现脏项，就replaceStaleEntry了事返回. 如果源码14的for循环一直没碰到脏项，也没有找到key的话，则来到源码14的28行，——直接插入&lt;key, value&gt; 到table[i]了,并且将table数组中包含Entry的数目+1, 然后源码14的第30行又调用了cleanSomeSlots，i就是刚刚插入&lt;key,value&gt;的索引. 注意，table[i]是刚刚插入的&lt;key,value&gt;, 所以肯定不是脏项. 所以cleanSomeSlots的第一个入参是一个非脏项的索引，回忆源码15 的24行和38行cleanSomeSlots的入参是table[i]=null（所以肯定也不是脏项），所以cleanSomeSlots对它的第一个入参的官方注释就是</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a position known NOT to hold a stale entry. The scan starts at the element after i.</span><br></pre></td></tr></table></figure>
<p>因为铁定不是脏项，这就是为什么源码17，即cleanSomeSlots的源码第6行上来就获取i后面的元素的原因了——因为table[i]肯定不是脏项嘛~ 因为cleanSomeSlots的源码已经细说过了，所以源码14的第30行说的就是如果在table[i]直接插入&lt;key, value&gt;的过程中没发现脏项并且已经超出阈值的话，就要扩容并且重哈希，即我们走进源码14 的第31行的rehash方法.</p>
<p>java.lang.ThreadLocal.ThreadLocalMap.rehash()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Use lower threshold for doubling to avoid hysteresis</span></span><br><span class="line">            <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">                resize();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>​                                                                                源码18</p>
<p>首先进行的是</p>
<p>java.lang.ThreadLocal.ThreadLocalMap.expungeStaleEntries()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Expunge all stale entries in the table.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                Entry e = tab[j];</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) <span class="comment">// 如果e是脏项</span></span><br><span class="line">                    expungeStaleEntry(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>​                                                                                        源码19</p>
<p>注意！这会儿是动真格的了! 不再是仅仅是附近的，而是如注释所说——“Expunge all stale entries in the table.”.</p>
<p>算法很简单——就是一旦发现脏项，就调用expungeStaleEntry进行清除.</p>
<p>然后源码18的第5行就是说如果当前table中拥有的条目数&gt;=3/4*阈值，注意，阈值初始是table的2/3，所以大概就是说如果table中的条目数&gt;=table的长度的一半的话，则就会进行扩容，跟进resize方法</p>
<p>java.lang.ThreadLocal.ThreadLocalMap.resize()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Double the capacity of the table.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Entry[] oldTab = table;</span><br><span class="line">            <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">            <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">            Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">                Entry e = oldTab[j];</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">                    <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123; <span class="comment">// 处理掉脏项</span></span><br><span class="line">                        e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC，防止内存泄漏</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>); <span class="comment">// 计算老数组中的元素在新数组中的索引</span></span><br><span class="line">                        <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                            h = nextIndex(h, newLen); <span class="comment">// 开放地址法之线性探测处理哈希冲突</span></span><br><span class="line">                        newTab[h] = e;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            setThreshold(newLen);</span><br><span class="line">            size = count;</span><br><span class="line">            table = newTab;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>​                                                                                        源码20</p>
<p>resize扩容的源码很简单，就是将原数组的length扩倍，然后将原table数组中的东西搬到新数组中去，只不过第18行计算新的位置的时候用的是新数组的长度而不是老数组的长度（因为显然哈希要针对新数组进行嘛~）并且将老数组元素中的脏项释放掉它的value（防止内存泄漏）</p>
<p>好了，至此ThreadLocalMap中最为重要的set方法的源码已经解析完毕. 其他的方法的源码就变得简单起来. 我们来彻底解析一下ThreadLocal中的API</p>
<h4 id="java-lang-ThreadLocal-get"><a href="#java-lang-ThreadLocal-get" class="headerlink" title="java.lang.ThreadLocal.get()"></a>java.lang.ThreadLocal.get()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​                                                                                        源码21</p>
<p>首先拿到Thread中的ThreadLocalMap，然后调用此ThreadLocalMap中的getEntry方法</p>
<p>java.lang.ThreadLocal.ThreadLocalMap.getEntry(ThreadLocal&lt;?&gt;)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>); <span class="comment">// 计算散列</span></span><br><span class="line">            Entry e = table[i];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key) <span class="comment">// 如果找到了，直接返回条目</span></span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> getEntryAfterMiss(key, i, e); <span class="comment">// 如果没有命中,要么e是null，要么e.get()!=key(注意，可能是null，即是脏项)</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>​                                                                                源码22</p>
<p>java.lang.ThreadLocal.ThreadLocalMap.getEntryAfterMiss(ThreadLocal&lt;?&gt;, int, Entry)，其中入参e是鸠占鹊巢中的鸠，i是巢， key是鹊的key</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">                <span class="keyword">if</span> (k == key)</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>) <span class="comment">// 如果是脏项</span></span><br><span class="line">                    expungeStaleEntry(i); <span class="comment">// 处理脏项，并且对于脏项后续的项——是脏项就处理，不是脏项就重哈希，i是脏项索引，处理掉了，则tab[i]就是null，除非在重哈希阶段tab[i]重新有了值</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    i = nextIndex(i, len); <span class="comment">// 下一位</span></span><br><span class="line">                e = tab[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>​                                                                                                源码23</p>
<h4 id="java-lang-ThreadLocal-set-T"><a href="#java-lang-ThreadLocal-set-T" class="headerlink" title="java.lang.ThreadLocal.set(T)"></a>java.lang.ThreadLocal.set(T)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​                                                                                源码24</p>
<p>关于第5行，我们之前是详尽分析过了的(源码14)，关于第七行，源码7也分析过了.</p>
<h4 id="java-lang-ThreadLocal-remove"><a href="#java-lang-ThreadLocal-remove" class="headerlink" title="java.lang.ThreadLocal.remove()"></a>java.lang.ThreadLocal.remove()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">         <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">             m.remove(<span class="keyword">this</span>);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>​                                                                                    源码25</p>
<p>java.lang.ThreadLocal.ThreadLocalMap.remove(ThreadLocal&lt;?&gt;)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Remove the entry for key.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                 e != <span class="keyword">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123; <span class="comment">// 采用线性探测的方法找到key，然后调用expungeStaleEntry对其进行清除</span></span><br><span class="line">                <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">                    e.clear();</span><br><span class="line">                    expungeStaleEntry(i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>​                                                                                                源码26</p>
<p>其实说到这里，感觉挺搞笑的~ 为什么? 因为一般我们项目里面也不可能对ThreadLocal进行滥用，一般顶多就是1个，2个左右，而table初始化的容量就有16，基本上不会存在哈希冲突的可能性.</p>
<p>分析完ThreadLocal的源码之后，我们来分析一下ThreadLocal的子类——InheritableThreadLocal</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>它的作用是什么呢? 这就不得不从线程类的构造器说起</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        init(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Thread.init</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">long</span> stackSize)</span> </span>&#123;</span><br><span class="line">        init(g, target, name, stackSize, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Thread.init</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123; <span class="comment">// inheritThreadLocals传入的是true</span></span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name cannot be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">   ...</span><br><span class="line">       Thread parent = currentThread();</span><br><span class="line">    ...</span><br><span class="line">       <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">java.lang.Thread.currentThread()</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> Thread <span class="title">currentThread</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>​                                                                            源码27</p>
<p>值得注意的是源码27的第23行，注意，inheritableThreadLocals是Thread的一个属性，它也是ThreadLocalMap类型的，和Thread的threadLocals属性一样. 但是不同的是，Thread的threadLocals属性不在Thread的构造器中初始化，而是在ThreadLocal的set方法中的createMap（源码1的第七行）被初始化的. 而Thread的inheritableThreadLocals是在Thread的构造器中初始化的. 跟进源码27的第23行</p>
<p>java.lang.ThreadLocal.createInheritedMap(ThreadLocalMap)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalMap(parentMap);</span><br></pre></td></tr></table></figure>
<p>继续跟</p>
<p>java.lang.ThreadLocal.ThreadLocalMap.ThreadLocalMap(ThreadLocalMap)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">            Entry[] parentTable = parentMap.table;</span><br><span class="line">            <span class="keyword">int</span> len = parentTable.length;</span><br><span class="line">            setThreshold(len);</span><br><span class="line">            table = <span class="keyword">new</span> Entry[len];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                Entry e = parentTable[j];</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// e是父线程的inheritableThreadLocals属性中的table数组的元素</span></span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">                    <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        Object value = key.childValue(e.value);</span><br><span class="line">                        Entry c = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">                        <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">                            h = nextIndex(h, len);</span><br><span class="line">                        table[h] = c;</span><br><span class="line">                        size++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>​                                                                                源码28</p>
<p>其实源码28就是使用父线程的inheritableThreadLocals属性（源码27 的23行）对子线程的inheritableThreadLocals属性进行初始化.初始化的方法也就是遍历父线程的inheritableThreadLocals（一个ThreadLocalMap变量）的table数组（即哈希表），然后将其复制到子线程的inheritableThreadLocals（一个ThreadLocalMap）的哈希表（即table数组）中去.  但是复制的过程中并不是强制要求是完全复制的——允许子线程进行一定程度的定制. 定制之道就在于源码28的第13行.  即我们可以让我们的ThreadLocal变量是InheritableThreadLocal变量，然后覆写其中的childValue方法（ThreadLocal的childValue方法直接抛出UnsupportedOperationException异常，一种RuntimeException）. 即可实现父线程（例如main线程）的值的定制.  而InheritableThreadLocal的set、get、remove方法其实都是调用其父类ThreadLocal的, InheritableThreadLocal仅仅覆写了以下三个关键方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123; <span class="comment">// 意味着允许自定义子类进行覆写</span></span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​                                                                                    源码29</p>
<p>也就是说，对于InheritableThreadLocal而言，它的set、get方法和ThreadLocal不一样，后者操作的对象是Thread中的threadLocals属性，而前者操作的是Thread的inheritableThreadLocals属性. </p>
<p>说的比较抽象，参见下面的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yfs.threadlocal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义InheritableThreadLocal</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yfs</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInheritableThreadLocal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 线程本地遍变量 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InheritableThreadLocal&lt;Integer&gt; INHERITABLE_THREAD_LOCAL = <span class="keyword">new</span> InheritableThreadLocal&lt;Integer&gt;() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">protected</span> Integer <span class="title">childValue</span><span class="params">(Integer parentValue)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> parentValue &lt;&lt; <span class="number">1</span>; <span class="comment">// Thread中的inheritableThreadLocals属性的初始化是乘以2</span></span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> INHERITABLE_THREAD_LOCAL.get();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">		INHERITABLE_THREAD_LOCAL.set(value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyIntegerTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">"获取值: "</span> + get());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> MyIntegerTask()).start(); <span class="comment">// 主线程中启动子线程1</span></span><br><span class="line">		TimeUnit.SECONDS.sleep(<span class="number">1</span>); <span class="comment">// 确保是在主线程往INHERITABLE_THREAD_LOCAL中塞入10之前启动的子线程1</span></span><br><span class="line">		set(<span class="number">10</span>); <span class="comment">// 主线程塞进10</span></span><br><span class="line">		TimeUnit.SECONDS.sleep(<span class="number">1</span>); <span class="comment">// 确保是在主线程往INHERITABLE_THREAD_LOCAL中塞入10之后启动的子线程2</span></span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> MyIntegerTask()).start(); <span class="comment">// 主线程中启动子线程2</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 控制台打印 </span></span><br><span class="line"><span class="comment"> * Thread-0获取值: null </span></span><br><span class="line"><span class="comment"> * Thread-1获取值: 20</span></span><br><span class="line"><span class="comment"> * 这是因为，子线程2的inheritableThreadLocals属性初始化的时候，采用的是主线程（即父线程）的inheritableThreadLocals属性</span></span><br><span class="line"><span class="comment"> * 而父线程的inheritableThreadLocals属性什么时候有值的呢? 就是在主线程调用set(10)的时候，其实是INHERITABLE_THREAD_LOCAL找到</span></span><br><span class="line"><span class="comment"> * 主线程的inheritableThreadLocals属性，往里面塞进了&lt;INHERITABLE_THREAD_LOCAL, 10&gt; 这个键值对，则子线程2启动的时候</span></span><br><span class="line"><span class="comment"> * 它的inheritableThreadLocals里面就是&lt;INHERITABLE_THREAD_LOCAL, 20&gt;了.</span></span><br><span class="line"><span class="comment"> * 子线程1之所以是null，是因为它启动的时候，父线程的inheritableThreadLocals属性还是空呢~</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h4 id="ThreadLocal常见的应用场景以及最佳实践"><a href="#ThreadLocal常见的应用场景以及最佳实践" class="headerlink" title="ThreadLocal常见的应用场景以及最佳实践"></a>ThreadLocal常见的应用场景以及最佳实践</h4><p>讲到了最后，我们来谈谈ThreadLocal在日常项目中的使用.  一般都是在项目中搞一个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XXXCache</span> </span>&#123; <span class="comment">// 或者叫XXXHolder</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;ZZZ&gt; zzz = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则我们在不同线程中就可以调用</p>
<p>XXXCache.set(一些参数)，则可以在别的地方通过XXXCache.get() 获取到当前请求线程的这些参数.  十分方便的实现了线程隔离——支撑了高并发（因为无锁）.</p>
<p>因为之前谈到了内存泄漏问题，所以ThreadLocal的最佳实践是——一旦当前线程（例如请求线程）使用完毕了该ThreadLocal变量，最好调用ThreadLocal.remove() 方法，即通知当前线程中它的ThreadLocalMap的哈希表table中移除该Entry中的键对应的value的强引用, 并且将此entry项的强引用去除. 这样就不会造成value的内存泄漏.</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>【1】<a href="https://yfsyfs.github.io/2019/06/18/Spring-事务源码解析（后篇）/" target="_blank" rel="noopener">https://yfsyfs.github.io/2019/06/18/Spring-%E4%BA%8B%E5%8A%A1%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E5%90%8E%E7%AF%87%EF%BC%89/</a></p>
<p>【2】<a href="https://yfsyfs.github.io/2019/06/27/java并发编程实践-3-3-线程封闭/" target="_blank" rel="noopener">https://yfsyfs.github.io/2019/06/27/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5-3-3-%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD/</a></p>
<p>【3】<a href="https://yfsyfs.github.io/2019/06/28/Java中的-强引用、软引用、弱引用、虚引用/" target="_blank" rel="noopener">https://yfsyfs.github.io/2019/06/28/Java%E4%B8%AD%E7%9A%84-%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8/</a></p>
<p>【4】<a href="https://yfsyfs.github.io/2019/06/07/java-util-HashMap-源码分析/" target="_blank" rel="noopener">https://yfsyfs.github.io/2019/06/07/java-util-HashMap-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</a></p>
<p>【5】<a href="https://yfsyfs.github.io/2019/06/28/WeakHashMap-源码解读/" target="_blank" rel="noopener">https://yfsyfs.github.io/2019/06/28/WeakHashMap-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/27/ThreadLocal-源码解读/" data-id="cjzma61hc01imakvmxcd2of0j" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JDK/">JDK</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后端/">后端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/06/28/Java中的-强引用、软引用、弱引用、虚引用/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Java中的 强引用、软引用、弱引用、虚引用
        
      </div>
    </a>
  
  
    <a href="/2019/06/27/java并发编程实践-3-3-线程封闭/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">java并发编程实践 3.3 线程封闭</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/01背包/">01背包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/51nod/">51nod</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BST/">BST</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-Primer/">C++ Primer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CRT/">CRT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C和指针/">C和指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DAG/">DAG</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DFS/">DFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DP/">DP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FFT/">FFT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HotSpot/">HotSpot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Huffman树/">Huffman树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JDK/">JDK</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JMM/">JMM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JRE/">JRE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Johnson不等式/">Johnson不等式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/KMP/">KMP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LCA/">LCA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LCS/">LCS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LDAP/">LDAP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LIS/">LIS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MST/">MST</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Manacher算法/">Manacher算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Miller-Rabin/">Miller-Rabin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Oauth2-0/">Oauth2.0</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenJudge/">OpenJudge</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pollard-rho/">Pollard rho</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RMQ/">RMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ST/">ST</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SVN/">SVN</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/String/">String</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tarjan/">Tarjan</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/activemq/">activemq</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bfs/">bfs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-c/">c/c++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dfs/">dfs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dijkstra/">dijkstra</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dp/">dp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/fft/">fft</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/fzu/">fzu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gradle/">gradle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hadoop/">hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hdfs/">hdfs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hdu/">hdu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hibernate/">hibernate</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hustoj/">hustoj</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java并发编程实践/">java并发编程实践</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jdbc/">jdbc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jpa/">jpa</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/karatsuba/">karatsuba</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kd树/">kd树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kmp/">kmp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kth/">kth</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/">leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/libreoj/">libreoj</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lightoj/">lightoj</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mapreduce/">mapreduce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/">node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oj/">oj</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oracle/">oracle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/poj/">poj</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/postgresql/">postgresql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sbt/">sbt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sdutoj/">sdutoj</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/servlet/">servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springboot/">springboot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springmvc/">springmvc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql/">sql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swagger/">swagger</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/synchronized/">synchronized</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/topK/">topK</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/treap/">treap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/trie/">trie</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/uva/">uva</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/volatile/">volatile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/zzulioj/">zzulioj</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/中国剩余定理/">中国剩余定理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/事务/">事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二分图/">二分图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二分查找/">二分查找</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二分答案/">二分答案</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二叉树/">二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/交叉染色法/">交叉染色法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/优先队列/">优先队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/位图/">位图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内存模型/">内存模型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分支限界/">分支限界</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分治/">分治</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分解素因数/">分解素因数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/划分数/">划分数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/剑指offer/">剑指offer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/剪枝/">剪枝</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动态查找/">动态查找</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动态规划/">动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/原生js/">原生js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/同步/">同步</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后台/">后台</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后端/">后端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后端，数据库-mysql/">后端，数据库, mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后缀树/">后缀树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/启发式搜索/">启发式搜索</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/哈希/">哈希</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/回文/">回文</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图/">图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/在线算法/">在线算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/堆/">堆</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/堆排/">堆排</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/堆排序/">堆排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多重背包/">多重背包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多重集组合数/">多重集组合数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/大数据/">大数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字符串/">字符串</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字符串匹配/">字符串匹配</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/完全背包/">完全背包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/宽搜/">宽搜</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/小程序/">小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/左式堆/">左式堆</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/带权并查集/">带权并查集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/平衡查找树/">平衡查找树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/并发/">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/并查集/">并查集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/强连通/">强连通</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/强连通分支/">强连通分支</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/归并排序/">归并排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/心语/">心语</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/快排/">快排</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/快速幂/">快速幂</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/性能优化/">性能优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/感悟/">感悟</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/扩展KMP/">扩展KMP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/扩展欧几里得/">扩展欧几里得</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/抓包/">抓包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/拓扑排序/">拓扑排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/排序/">排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/操作系统/">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/教材/">教材</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数学/">数学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数组/">数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数论/">数论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最大公约数/">最大公约数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最小正整数解/">最小正整数解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最小生成树/">最小生成树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最短路/">最短路</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最短路径/">最短路径</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最长回文子串/">最长回文子串</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/有向图/">有向图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/杂/">杂</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/板子/">板子</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/查找/">查找</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/查找树/">查找树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/栈/">栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树/">树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树堆/">树堆</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树状数组/">树状数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/桶排序/">桶排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模块化/">模块化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模板/">模板</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/次短路/">次短路</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/欧几里得/">欧几里得</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/欧拉函数/">欧拉函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/欧拉环游/">欧拉环游</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/泛洪/">泛洪</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/洛谷/">洛谷</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/深搜/">深搜</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码/">源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码分析/">源码分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/滚动数组/">滚动数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/版本控制/">版本控制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/牛客网/">牛客网</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/生成树/">生成树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/百练/">百练</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/离散化/">离散化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/筛法/">筛法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/简历/">简历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/素数测试/">素数测试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/约瑟夫环/">约瑟夫环</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线上问题/">线上问题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线性同余方程/">线性同余方程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线段树/">线段树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/组件化/">组件化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编译原理/">编译原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络协议/">网络协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/背包/">背包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/自己动手用java写编译器/">自己动手用java写编译器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/菜鸟教材/">菜鸟教材</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/词典/">词典</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/贪心/">贪心</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/轮播图/">轮播图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/连通/">连通</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/连通分支/">连通分支</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/连通性/">连通性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/逆元/">逆元</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/逆序数/">逆序数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/递归/">递归</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/遍历/">遍历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/邻接多重表/">邻接多重表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/链表/">链表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/锁/">锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/队列/">队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/集合/">集合</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/静态查找树/">静态查找树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面试/">面试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/高精度/">高精度</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/01背包/" style="font-size: 12.31px;">01背包</a> <a href="/tags/51nod/" style="font-size: 10px;">51nod</a> <a href="/tags/BST/" style="font-size: 10px;">BST</a> <a href="/tags/C/" style="font-size: 17.69px;">C</a> <a href="/tags/C/" style="font-size: 11.15px;">C++</a> <a href="/tags/C-Primer/" style="font-size: 10px;">C++ Primer</a> <a href="/tags/CRT/" style="font-size: 10px;">CRT</a> <a href="/tags/C和指针/" style="font-size: 16.92px;">C和指针</a> <a href="/tags/DAG/" style="font-size: 10.77px;">DAG</a> <a href="/tags/DFS/" style="font-size: 10.38px;">DFS</a> <a href="/tags/DP/" style="font-size: 10.77px;">DP</a> <a href="/tags/FFT/" style="font-size: 10px;">FFT</a> <a href="/tags/HotSpot/" style="font-size: 10px;">HotSpot</a> <a href="/tags/Huffman树/" style="font-size: 10px;">Huffman树</a> <a href="/tags/JDK/" style="font-size: 15.77px;">JDK</a> <a href="/tags/JMM/" style="font-size: 10.38px;">JMM</a> <a href="/tags/JRE/" style="font-size: 10px;">JRE</a> <a href="/tags/JVM/" style="font-size: 10.77px;">JVM</a> <a href="/tags/Johnson不等式/" style="font-size: 10px;">Johnson不等式</a> <a href="/tags/KMP/" style="font-size: 10px;">KMP</a> <a href="/tags/LCA/" style="font-size: 10.77px;">LCA</a> <a href="/tags/LCS/" style="font-size: 10.38px;">LCS</a> <a href="/tags/LDAP/" style="font-size: 10.38px;">LDAP</a> <a href="/tags/LIS/" style="font-size: 10px;">LIS</a> <a href="/tags/MST/" style="font-size: 10px;">MST</a> <a href="/tags/Manacher算法/" style="font-size: 10px;">Manacher算法</a> <a href="/tags/Miller-Rabin/" style="font-size: 10.77px;">Miller-Rabin</a> <a href="/tags/Oauth2-0/" style="font-size: 10px;">Oauth2.0</a> <a href="/tags/OpenJudge/" style="font-size: 10px;">OpenJudge</a> <a href="/tags/Pollard-rho/" style="font-size: 10.38px;">Pollard rho</a> <a href="/tags/RMQ/" style="font-size: 11.54px;">RMQ</a> <a href="/tags/ST/" style="font-size: 10px;">ST</a> <a href="/tags/SVN/" style="font-size: 10px;">SVN</a> <a href="/tags/Spring/" style="font-size: 14.23px;">Spring</a> <a href="/tags/String/" style="font-size: 10.38px;">String</a> <a href="/tags/Tarjan/" style="font-size: 10px;">Tarjan</a> <a href="/tags/activemq/" style="font-size: 10px;">activemq</a> <a href="/tags/bfs/" style="font-size: 10.77px;">bfs</a> <a href="/tags/c-c/" style="font-size: 10px;">c/c++</a> <a href="/tags/dfs/" style="font-size: 12.69px;">dfs</a> <a href="/tags/dijkstra/" style="font-size: 11.15px;">dijkstra</a> <a href="/tags/dp/" style="font-size: 14.62px;">dp</a> <a href="/tags/fft/" style="font-size: 10px;">fft</a> <a href="/tags/fzu/" style="font-size: 10.38px;">fzu</a> <a href="/tags/gradle/" style="font-size: 10.38px;">gradle</a> <a href="/tags/hadoop/" style="font-size: 10.38px;">hadoop</a> <a href="/tags/hdfs/" style="font-size: 10.38px;">hdfs</a> <a href="/tags/hdu/" style="font-size: 15.77px;">hdu</a> <a href="/tags/hibernate/" style="font-size: 10px;">hibernate</a> <a href="/tags/hustoj/" style="font-size: 10px;">hustoj</a> <a href="/tags/java并发编程实践/" style="font-size: 15.38px;">java并发编程实践</a> <a href="/tags/jdbc/" style="font-size: 10.38px;">jdbc</a> <a href="/tags/jpa/" style="font-size: 10px;">jpa</a> <a href="/tags/karatsuba/" style="font-size: 10px;">karatsuba</a> <a href="/tags/kd树/" style="font-size: 10px;">kd树</a> <a href="/tags/kmp/" style="font-size: 10px;">kmp</a> <a href="/tags/kth/" style="font-size: 10.38px;">kth</a> <a href="/tags/leetcode/" style="font-size: 10.38px;">leetcode</a> <a href="/tags/libreoj/" style="font-size: 10px;">libreoj</a> <a href="/tags/lightoj/" style="font-size: 11.54px;">lightoj</a> <a href="/tags/mapreduce/" style="font-size: 10px;">mapreduce</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/node/" style="font-size: 10px;">node</a> <a href="/tags/oj/" style="font-size: 19.23px;">oj</a> <a href="/tags/oracle/" style="font-size: 10px;">oracle</a> <a href="/tags/poj/" style="font-size: 16.54px;">poj</a> <a href="/tags/postgresql/" style="font-size: 10px;">postgresql</a> <a href="/tags/sbt/" style="font-size: 10px;">sbt</a> <a href="/tags/sdutoj/" style="font-size: 10.38px;">sdutoj</a> <a href="/tags/servlet/" style="font-size: 10px;">servlet</a> <a href="/tags/spring/" style="font-size: 12.31px;">spring</a> <a href="/tags/springboot/" style="font-size: 10.77px;">springboot</a> <a href="/tags/springmvc/" style="font-size: 10.38px;">springmvc</a> <a href="/tags/sql/" style="font-size: 10px;">sql</a> <a href="/tags/swagger/" style="font-size: 10px;">swagger</a> <a href="/tags/synchronized/" style="font-size: 10.38px;">synchronized</a> <a href="/tags/topK/" style="font-size: 10.38px;">topK</a> <a href="/tags/treap/" style="font-size: 10px;">treap</a> <a href="/tags/trie/" style="font-size: 12.31px;">trie</a> <a href="/tags/uva/" style="font-size: 10.38px;">uva</a> <a href="/tags/volatile/" style="font-size: 10.38px;">volatile</a> <a href="/tags/vue/" style="font-size: 10.77px;">vue</a> <a href="/tags/zzulioj/" style="font-size: 10px;">zzulioj</a> <a href="/tags/中国剩余定理/" style="font-size: 10px;">中国剩余定理</a> <a href="/tags/事务/" style="font-size: 11.54px;">事务</a> <a href="/tags/二分图/" style="font-size: 10px;">二分图</a> <a href="/tags/二分查找/" style="font-size: 10px;">二分查找</a> <a href="/tags/二分答案/" style="font-size: 10px;">二分答案</a> <a href="/tags/二叉树/" style="font-size: 10.38px;">二叉树</a> <a href="/tags/交叉染色法/" style="font-size: 10px;">交叉染色法</a> <a href="/tags/优先队列/" style="font-size: 13.08px;">优先队列</a> <a href="/tags/位图/" style="font-size: 10px;">位图</a> <a href="/tags/内存模型/" style="font-size: 10.38px;">内存模型</a> <a href="/tags/分支限界/" style="font-size: 10px;">分支限界</a> <a href="/tags/分治/" style="font-size: 10px;">分治</a> <a href="/tags/分解素因数/" style="font-size: 10.77px;">分解素因数</a> <a href="/tags/划分数/" style="font-size: 10px;">划分数</a> <a href="/tags/前端/" style="font-size: 11.54px;">前端</a> <a href="/tags/剑指offer/" style="font-size: 10px;">剑指offer</a> <a href="/tags/剪枝/" style="font-size: 10px;">剪枝</a> <a href="/tags/动态查找/" style="font-size: 10px;">动态查找</a> <a href="/tags/动态规划/" style="font-size: 11.92px;">动态规划</a> <a href="/tags/原生js/" style="font-size: 10px;">原生js</a> <a href="/tags/同步/" style="font-size: 10.38px;">同步</a> <a href="/tags/后台/" style="font-size: 10px;">后台</a> <a href="/tags/后端/" style="font-size: 18.85px;">后端</a> <a href="/tags/后端，数据库-mysql/" style="font-size: 10px;">后端，数据库, mysql</a> <a href="/tags/后缀树/" style="font-size: 10px;">后缀树</a> <a href="/tags/启发式搜索/" style="font-size: 10px;">启发式搜索</a> <a href="/tags/哈希/" style="font-size: 11.15px;">哈希</a> <a href="/tags/回文/" style="font-size: 10px;">回文</a> <a href="/tags/图/" style="font-size: 18.08px;">图</a> <a href="/tags/在线算法/" style="font-size: 10px;">在线算法</a> <a href="/tags/堆/" style="font-size: 10px;">堆</a> <a href="/tags/堆排/" style="font-size: 10.38px;">堆排</a> <a href="/tags/堆排序/" style="font-size: 10px;">堆排序</a> <a href="/tags/多重背包/" style="font-size: 10px;">多重背包</a> <a href="/tags/多重集组合数/" style="font-size: 10px;">多重集组合数</a> <a href="/tags/大数据/" style="font-size: 10.77px;">大数据</a> <a href="/tags/字符串/" style="font-size: 13.46px;">字符串</a> <a href="/tags/字符串匹配/" style="font-size: 10px;">字符串匹配</a> <a href="/tags/完全背包/" style="font-size: 10px;">完全背包</a> <a href="/tags/宽搜/" style="font-size: 10.38px;">宽搜</a> <a href="/tags/小程序/" style="font-size: 10px;">小程序</a> <a href="/tags/左式堆/" style="font-size: 10px;">左式堆</a> <a href="/tags/带权并查集/" style="font-size: 10px;">带权并查集</a> <a href="/tags/平衡查找树/" style="font-size: 10px;">平衡查找树</a> <a href="/tags/并发/" style="font-size: 16.15px;">并发</a> <a href="/tags/并查集/" style="font-size: 11.92px;">并查集</a> <a href="/tags/强连通/" style="font-size: 10.38px;">强连通</a> <a href="/tags/强连通分支/" style="font-size: 10px;">强连通分支</a> <a href="/tags/归并排序/" style="font-size: 10px;">归并排序</a> <a href="/tags/心语/" style="font-size: 10px;">心语</a> <a href="/tags/快排/" style="font-size: 10.77px;">快排</a> <a href="/tags/快速幂/" style="font-size: 12.31px;">快速幂</a> <a href="/tags/性能优化/" style="font-size: 10px;">性能优化</a> <a href="/tags/感悟/" style="font-size: 10px;">感悟</a> <a href="/tags/扩展KMP/" style="font-size: 10.77px;">扩展KMP</a> <a href="/tags/扩展欧几里得/" style="font-size: 10.77px;">扩展欧几里得</a> <a href="/tags/抓包/" style="font-size: 10px;">抓包</a> <a href="/tags/拓扑排序/" style="font-size: 10.38px;">拓扑排序</a> <a href="/tags/排序/" style="font-size: 15px;">排序</a> <a href="/tags/操作系统/" style="font-size: 10.38px;">操作系统</a> <a href="/tags/教材/" style="font-size: 19.62px;">教材</a> <a href="/tags/数学/" style="font-size: 13.85px;">数学</a> <a href="/tags/数据库/" style="font-size: 10px;">数据库</a> <a href="/tags/数组/" style="font-size: 10px;">数组</a> <a href="/tags/数论/" style="font-size: 12.31px;">数论</a> <a href="/tags/最大公约数/" style="font-size: 10px;">最大公约数</a> <a href="/tags/最小正整数解/" style="font-size: 10.38px;">最小正整数解</a> <a href="/tags/最小生成树/" style="font-size: 10px;">最小生成树</a> <a href="/tags/最短路/" style="font-size: 10.77px;">最短路</a> <a href="/tags/最短路径/" style="font-size: 12.31px;">最短路径</a> <a href="/tags/最长回文子串/" style="font-size: 10px;">最长回文子串</a> <a href="/tags/有向图/" style="font-size: 10px;">有向图</a> <a href="/tags/杂/" style="font-size: 10px;">杂</a> <a href="/tags/板子/" style="font-size: 10px;">板子</a> <a href="/tags/查找/" style="font-size: 10px;">查找</a> <a href="/tags/查找树/" style="font-size: 13.08px;">查找树</a> <a href="/tags/栈/" style="font-size: 12.31px;">栈</a> <a href="/tags/树/" style="font-size: 17.31px;">树</a> <a href="/tags/树堆/" style="font-size: 10px;">树堆</a> <a href="/tags/树状数组/" style="font-size: 11.15px;">树状数组</a> <a href="/tags/桶排序/" style="font-size: 10px;">桶排序</a> <a href="/tags/模块化/" style="font-size: 10px;">模块化</a> <a href="/tags/模板/" style="font-size: 12.69px;">模板</a> <a href="/tags/次短路/" style="font-size: 10px;">次短路</a> <a href="/tags/欧几里得/" style="font-size: 10px;">欧几里得</a> <a href="/tags/欧拉函数/" style="font-size: 10.38px;">欧拉函数</a> <a href="/tags/欧拉环游/" style="font-size: 10px;">欧拉环游</a> <a href="/tags/泛洪/" style="font-size: 10px;">泛洪</a> <a href="/tags/洛谷/" style="font-size: 10.38px;">洛谷</a> <a href="/tags/深搜/" style="font-size: 11.54px;">深搜</a> <a href="/tags/源码/" style="font-size: 18.46px;">源码</a> <a href="/tags/源码分析/" style="font-size: 11.15px;">源码分析</a> <a href="/tags/滚动数组/" style="font-size: 10px;">滚动数组</a> <a href="/tags/版本控制/" style="font-size: 10px;">版本控制</a> <a href="/tags/牛客网/" style="font-size: 11.15px;">牛客网</a> <a href="/tags/生成树/" style="font-size: 10.38px;">生成树</a> <a href="/tags/百练/" style="font-size: 10.38px;">百练</a> <a href="/tags/离散化/" style="font-size: 10px;">离散化</a> <a href="/tags/筛法/" style="font-size: 11.15px;">筛法</a> <a href="/tags/简历/" style="font-size: 10px;">简历</a> <a href="/tags/算法/" style="font-size: 20px;">算法</a> <a href="/tags/素数测试/" style="font-size: 10.77px;">素数测试</a> <a href="/tags/约瑟夫环/" style="font-size: 10px;">约瑟夫环</a> <a href="/tags/线上问题/" style="font-size: 10px;">线上问题</a> <a href="/tags/线性同余方程/" style="font-size: 10px;">线性同余方程</a> <a href="/tags/线段树/" style="font-size: 12.31px;">线段树</a> <a href="/tags/组件化/" style="font-size: 10px;">组件化</a> <a href="/tags/编译原理/" style="font-size: 13.85px;">编译原理</a> <a href="/tags/网络协议/" style="font-size: 10px;">网络协议</a> <a href="/tags/背包/" style="font-size: 13.08px;">背包</a> <a href="/tags/自己动手用java写编译器/" style="font-size: 13.85px;">自己动手用java写编译器</a> <a href="/tags/菜鸟教材/" style="font-size: 10.77px;">菜鸟教材</a> <a href="/tags/设计模式/" style="font-size: 10.77px;">设计模式</a> <a href="/tags/词典/" style="font-size: 10px;">词典</a> <a href="/tags/贪心/" style="font-size: 11.54px;">贪心</a> <a href="/tags/轮播图/" style="font-size: 10px;">轮播图</a> <a href="/tags/连通/" style="font-size: 11.15px;">连通</a> <a href="/tags/连通分支/" style="font-size: 10.38px;">连通分支</a> <a href="/tags/连通性/" style="font-size: 11.54px;">连通性</a> <a href="/tags/逆元/" style="font-size: 10px;">逆元</a> <a href="/tags/逆序数/" style="font-size: 10.38px;">逆序数</a> <a href="/tags/递归/" style="font-size: 11.54px;">递归</a> <a href="/tags/遍历/" style="font-size: 10px;">遍历</a> <a href="/tags/邻接多重表/" style="font-size: 10.38px;">邻接多重表</a> <a href="/tags/链表/" style="font-size: 11.54px;">链表</a> <a href="/tags/锁/" style="font-size: 10.77px;">锁</a> <a href="/tags/队列/" style="font-size: 11.54px;">队列</a> <a href="/tags/集合/" style="font-size: 10px;">集合</a> <a href="/tags/静态查找树/" style="font-size: 10.38px;">静态查找树</a> <a href="/tags/面试/" style="font-size: 13.46px;">面试</a> <a href="/tags/高精度/" style="font-size: 13.08px;">高精度</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/08/22/dijkstra算法的证明/">dijkstra算法的证明</a>
          </li>
        
          <li>
            <a href="/2019/08/22/poj-1797-Heavy-Transportation-dijkstra/">poj 1797 Heavy Transportation dijkstra</a>
          </li>
        
          <li>
            <a href="/2019/08/22/hdu-2544-dijkstra模板/">hdu 2544 dijkstra模板</a>
          </li>
        
          <li>
            <a href="/2019/08/21/poj-3255-Roadblocks-dijkstra/">poj 3255 Roadblocks dijkstra</a>
          </li>
        
          <li>
            <a href="/2019/08/21/牛客网-二分图判定之交叉染色法/">牛客网 二分图判定之交叉染色法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>