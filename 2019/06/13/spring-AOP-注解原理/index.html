<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>spring AOP 注解原理 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="缘起我们知道，其实AOP是一种编程思想——面向切面. 即程序运行期间动态的将某段代码切入到指定位置进行运行的编程方式.  典型的用法可以参见【1】. 其实非java config的用法在之前使用xml的时候都大同小异的使用过. 但是本文就想从源码的角度分析Sping-AOP是如何实现的">
<meta name="keywords" content="源码,后端,Spring">
<meta property="og:type" content="article">
<meta property="og:title" content="spring AOP 注解原理">
<meta property="og:url" content="http://yoursite.com/2019/06/13/spring-AOP-注解原理/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="缘起我们知道，其实AOP是一种编程思想——面向切面. 即程序运行期间动态的将某段代码切入到指定位置进行运行的编程方式.  典型的用法可以参见【1】. 其实非java config的用法在之前使用xml的时候都大同小异的使用过. 但是本文就想从源码的角度分析Sping-AOP是如何实现的">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/2019/06/13/spring-AOP-注解原理/1.png">
<meta property="og:image" content="http://yoursite.com/2019/06/13/spring-AOP-注解原理/2.png">
<meta property="og:updated_time" content="2019-06-14T07:04:44.624Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="spring AOP 注解原理">
<meta name="twitter:description" content="缘起我们知道，其实AOP是一种编程思想——面向切面. 即程序运行期间动态的将某段代码切入到指定位置进行运行的编程方式.  典型的用法可以参见【1】. 其实非java config的用法在之前使用xml的时候都大同小异的使用过. 但是本文就想从源码的角度分析Sping-AOP是如何实现的">
<meta name="twitter:image" content="http://yoursite.com/2019/06/13/spring-AOP-注解原理/1.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <!--<link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">-->
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">影法師の物語</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-spring-AOP-注解原理" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/13/spring-AOP-注解原理/" class="article-date">
  <time datetime="2019-06-13T04:21:27.000Z" itemprop="datePublished">2019-06-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      spring AOP 注解原理
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h3><p>我们知道，其实AOP是一种编程思想——面向切面. 即程序运行期间动态的将某段代码切入到指定位置进行运行的编程方式.  典型的用法可以参见【1】. 其实非java config的用法在之前使用xml的时候都大同小异的使用过. 但是本文就想从源码的角度分析Sping-AOP是如何实现的</p>
<a id="more"></a>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="注册bean定义"><a href="#注册bean定义" class="headerlink" title="注册bean定义"></a>注册bean定义</h4><p>首先，纵观【1】，我们发现最值得怀疑的分析入手点就是 MainConfig上的注解@EnableAspectJAutoProxy了. 我们看看此注解干了什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">@Import</span>(AspectJAutoProxyRegistrar.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAspectJAutoProxy &#123;</span><br></pre></td></tr></table></figure>
<p>而Spring提供的 @Import注解的作用就是导入 AspectJAutoProxyRegistrar 到bean中去.</p>
<p>而我们看看AspectJAutoProxyRegistrar 这个类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AspectJAutoProxyRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>而ImportBeanDefinitionRegistrar接口的作用就是它的registerBeanDefinitions方法. 这个方法的作用就是手动注入bean. 我们看看其源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这个registerAspectJAnnotationAutoProxyCreatorIfNecessary的中文硬译就是 <code>注册一个AspectJAnnotationAutoProxyCreator,如果需要的话</code>.  但是按照【1】中的场景，显然就是<code>需要</code>, 不是吗?  所以我们有理由跟进去，不是吗?  随意跟进两步，我们看到了如下源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerOrEscalateApcAsRequired</span><span class="params">(Class&lt;?&gt; cls, BeanDefinitionRegistry registry, Object source)</span> </span>&#123;</span><br><span class="line">		Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line">		<span class="keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123; <span class="comment">// AUTO_PROXY_CREATOR_BEAN_NAME=org.springframework.aop.config.internalAutoProxyCreator</span></span><br><span class="line">			BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line">			<span class="keyword">if</span> (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;</span><br><span class="line">				<span class="keyword">int</span> currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());</span><br><span class="line">				<span class="keyword">int</span> requiredPriority = findPriorityForClass(cls);</span><br><span class="line">				<span class="keyword">if</span> (currentPriority &lt; requiredPriority) &#123;</span><br><span class="line">					apcDefinition.setBeanClassName(cls.getName());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition(cls);</span><br><span class="line">		beanDefinition.setSource(source);</span><br><span class="line">		beanDefinition.getPropertyValues().add(<span class="string">"order"</span>, Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">		beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">		registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);</span><br><span class="line">		<span class="keyword">return</span> beanDefinition;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>​                                        源码1</p>
<p>debug发现，上面的cls入参就是AnnotationAwareAspectJAutoProxyCreator. registry是DefaultListableBeanFactory(BeanDefinitionRegistry接口的一个实现类，从名字就能看出，registry用于bean定义信息的注册)，用于我们注册bean定义的东西.</p>
<p>上面代码的逻辑是先判断是否已经注册了id为org.springframework.aop.config.internalAutoProxyCreator（下简称internalAutoProxyCreator）的bean的话，则就做一些操作，我们目前是首入，所以这个判断条件不成立的. 所以我们来到了上面第18行代码. 最后返回的是 beanDefinition。哦，对，忘了说了，此调用栈的出发点自然是ioc容器启动的refresh方法（AbstractApplicationContext的）. 而且是refresh方法中的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Invoke factory processors registered as beans in the context. 调用 BeanFactoryPostProcessors来注册bean的定义信息</span></span><br><span class="line">				invokeBeanFactoryPostProcessors(beanFactory);</span><br></pre></td></tr></table></figure>
<p>​                            源码2</p>
<p>查阅Spring 4.3.12-RELEASE 官方文档，BeanFactoryPostProcessors和BeanPostProcessor 接口不同，前者用于<code>Customizing configuration metadata with a BeanFactoryPostProcessor</code>. 其原文如下</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The next extension point that we will look at is</span><br><span class="line">the org.springframework.beans.factory.config.BeanFactoryPostProcessor. The</span><br><span class="line">semantics of this interface are similar to those of the BeanPostProcessor, with one major difference:</span><br><span class="line">BeanFactoryPostProcessor operates on the bean configuration metadata; that is, the Spring IoC</span><br><span class="line">container allows a BeanFactoryPostProcessor to read the configuration metadata and potentially</span><br><span class="line">change it before the container instantiates any beans other than BeanFactoryPostProcessors.</span><br></pre></td></tr></table></figure>
<p>上面说的很明白了，BeanFactoryPostProcessors就是用于读取bean的定义的（只是定义，譬如长下面这个样子</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Root bean: class [org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator]; scope=; abstract=false; lazyInit=false; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null</span><br></pre></td></tr></table></figure>
<p>）. 而在【2】中，我们已经分析过BeanPostProcessor的作用了，就是初始化bean之后，再干点儿什么. 所以不难想象，BeanPostProcessor的处理一定在源码2之后. 证据还是在refresh方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">				invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">				registerBeanPostProcessors(beanFactory);</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">				finishBeanFactoryInitialization(beanFactory);</span><br></pre></td></tr></table></figure>
<p>​                                源码3</p>
<p>上面第一条是注册bean的定义（你看，源码1返回的不就是beanDefinition么?）第二条是注册BeanPostProcessors（bean的后置处理器）, 这些后置处理器的作用（正如【2】中所说）是拦截bean的初始化过程的. 第三条就是初始化bean. 期间会被第二条注册好的bean后置处理器进行拦截.</p>
<p>这是ioc初始化bean的基本过程. 即bean的定义在先. 要改bean的定义要在这里改.</p>
<p>好了，扯皮了一会儿. 回到源码1.  我们关注第18行代码，其中beanDefinition是AnnotationAwareAspectJAutoProxyCreator的bean的定义. 所以我们将AnnotationAwareAspectJAutoProxyCreator的bean的定义信息注册为了名（id）为internalAutoProxyCreator的bean. 则源码1结束，我们就向ioc容器中注册了一个这样的bean（自动代理创建器）定义信息.</p>
<p>ps: 这里顺便说一句源码1的第18行代码， 它做的事情是(其实在【3】中已经说过了)</p>
<p>org.springframework.beans.factory.support.DefaultListableBeanFactory.registerBeanDefinition(String, BeanDefinition)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">this</span>.beanDefinitionNames.add(beanName); <span class="comment">// beanDefinitionNames就是注册到ioc容器中的bean定义,beanDefinitionNames的官方注释就是List of bean definition names, in registration order</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>所以注册bean的定义信息其实就是往DefaultListableBeanFactory的beanDefinitionNames中添加beanName即可.</p>
<p>so, 这就完了? of course NOT!!!</p>
<h4 id="AnnotationAwareAspectJAutoProxyCreator"><a href="#AnnotationAwareAspectJAutoProxyCreator" class="headerlink" title="AnnotationAwareAspectJAutoProxyCreator"></a>AnnotationAwareAspectJAutoProxyCreator</h4><p>从上一小节，我们知道ioc容器中已经有了一个AnnotationAwareAspectJAutoProxyCreator的bean的定义信息. </p>
<p>ps: 其实，这里多说一句，其实springboot、springcloud或者spring本身有很多的 @EnableXXX 注解，一般的套路就是引入了某个bean，然后你要去研究这个bean，这个bean的功能研究透了, 整个原理就搞清楚了.</p>
<p>回到正题，ioc容器中已经有了一个这样的bean的定义信息，不用说我们也知道，肯定是要初始化这个bean的，不然引入他的定义干什么? 难道引入着好玩? 那么这个类长什么样子呢?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationAwareAspectJAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">AspectJAwareAdvisorAutoProxyCreator</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>然后一路狂点其父类，发现了我们感兴趣的东西</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">ProxyProcessorSupport</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">SmartInstantiationAwareBeanPostProcessor</span>, <span class="title">BeanFactoryAware</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>所以AnnotationAwareAspectJAutoProxyCreator实现了SmartInstantiationAwareBeanPostProcessor（一个 BeanPostProcessor接口的子接口）以及BeanFactoryAware接口. 这里需要注意的是，SmartInstantiationAwareBeanPostProcessor接口虽然是BeanPostProcessor的子接口，但是我们关心的接口方法并不是BeanPostProcessor的postProcessBeforeInitialization、postProcessAfterInitialization，而是postProcessBeforeInstantiation、postProcessAfterInstantiation，即把Initialization换成了Instantiation.</p>
<p>而且我们知道，既然AnnotationAwareAspectJAutoProxyCreator是一个BeanPostProcessor，所以是一定会在源码3中的第二步进行注册的.</p>
<p>现在我们来捋一下AnnotationAwareAspectJAutoProxyCreator中我们需要关心的方法. 显然就是setBeanFactory方法和上面说到的postProcessBeforeInstantiation、postProcessAfterInstantiation方法. 而这个在其父类AbstractAdvisorAutoProxyCreator中.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.setBeanFactory(beanFactory);</span><br><span class="line">		<span class="keyword">if</span> (!(beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">					<span class="string">"AdvisorAutoProxyCreator requires a ConfigurableListableBeanFactory: "</span> + beanFactory);</span><br><span class="line">		&#125;</span><br><span class="line">		initBeanFactory((ConfigurableListableBeanFactory) beanFactory);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>​                                        源码4</p>
<p>其中initBeanFactory（源码4的第八行）调用的是AnnotationAwareAspectJAutoProxyCreator自己的. 源码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.initBeanFactory(beanFactory);</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.aspectJAdvisorFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.aspectJAdvisorFactory = <span class="keyword">new</span> ReflectiveAspectJAdvisorFactory(beanFactory);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.aspectJAdvisorsBuilder =</span><br><span class="line">				<span class="keyword">new</span> BeanFactoryAspectJAdvisorsBuilderAdapter(beanFactory, <span class="keyword">this</span>.aspectJAdvisorFactory);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>​                                        源码5</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		Object cacheKey = getCacheKey(beanClass, beanName);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (beanName == <span class="keyword">null</span> || !<span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.advisedBeans.containsKey(cacheKey)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;</span><br><span class="line">				<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Create proxy here if we have a custom TargetSource.</span></span><br><span class="line">		<span class="comment">// Suppresses unnecessary default instantiation of the target bean:</span></span><br><span class="line">		<span class="comment">// The TargetSource will handle target instances in a custom fashion.</span></span><br><span class="line">		<span class="keyword">if</span> (beanName != <span class="keyword">null</span>) &#123;</span><br><span class="line">			TargetSource targetSource = getCustomTargetSource(beanClass, beanName);</span><br><span class="line">			<span class="keyword">if</span> (targetSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">this</span>.targetSourcedBeans.add(beanName);</span><br><span class="line">				Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);</span><br><span class="line">				Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);</span><br><span class="line">				<span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">				<span class="keyword">return</span> proxy;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>​                                        源码6</p>
<p>postProcessAfterInstantiation只是简单地返回true. </p>
<p>所以综上所述，我们只需要分析清楚AnnotationAwareAspectJAutoProxyCreator作为bean后置处理器做了哪些工作，作为BeanFactoryAware做了哪些工作，这些分析清楚了，AOP的原理就基本清楚了.</p>
<h4 id="registerBeanPostProcessors-注册bean后置处理器-的过程-以AnnotationAwareAspectJAutoProxyCreator为例"><a href="#registerBeanPostProcessors-注册bean后置处理器-的过程-以AnnotationAwareAspectJAutoProxyCreator为例" class="headerlink" title="registerBeanPostProcessors(注册bean后置处理器)的过程(以AnnotationAwareAspectJAutoProxyCreator为例)"></a>registerBeanPostProcessors(注册bean后置处理器)的过程(以AnnotationAwareAspectJAutoProxyCreator为例)</h4><p>注意源码3中的第二步, 我们一直强调说源码3的第一步用于注册bean的定义信息（往BeanDefinitionRegistry中注册），并没有初始化bean. 例如，我们已经往BeanDefinitionRegistry中注册了AnnotationAwareAspectJAutoProxyCreator的定义信息（它是一个BeanPostProcessor）. 但是这些BeanPostProcessor 是在源码3的第二步被初始化的.  那么它是怎么初始化的呢? 我们跟一下源码就会找到</p>
<p>org.springframework.context.support.PostProcessorRegistrationDelegate.registerBeanPostProcessors(ConfigurableListableBeanFactory, AbstractApplicationContext) 方法, 里面第一步就是</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>
<p>​                                源码7</p>
<p>表示获取已经注册的BeanPostProcessor类型的bean的定义信息. 不仅仅包含我们之前已经注册的AnnotationAwareAspectJAutoProxyCreator的定义信息，还有其他一些spring自带的BeanPostProcessor. 而且这里还会增加一些别的BeanPostProcessor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br></pre></td></tr></table></figure>
<p>​                                源码8</p>
<p>之后做的事情就是Separate between BeanPostProcessors that implement PriorityOrdered, Ordered, and the rest. 即将这些BeanPostProcessors 中实现了PriorityOrdered接口（Ordered的子接口）的放一起，实现了Ordered接口的放一起，剩下的没有实现Ordered接口的放一起. 最后将PriorityOrdered排序，Ordered排序，最后将这三部分又都加入到internalPostProcessors中去. 即在最后的internalPostProcessors中，实现了PriorityOrdered的排在最前，其次是实现了Ordered接口的，最后就是没实现Ordered接口的. 而且我们感兴趣的AnnotationAwareAspectJAutoProxyCreator实现了Ordered接口. 回到正题——在源码3的第二步我们是要初始化这些Bean后置处理器呢! 所以我们必须要初始化这个bean. 怎么初始化的呢? 依旧是在此方法(PostProcessorRegistrationDelegate.registerBeanPostProcessors)中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// First, register the BeanPostProcessors that implement PriorityOrdered.</span></span><br><span class="line"><span class="comment">// Next, register the BeanPostProcessors that implement Ordered.</span></span><br><span class="line">registerBeanPostProcessors(beanFactory, orderedPostProcessors); <span class="comment">// 真正的注册orderedPostProcessors（我们可爱的AnnotationAwareAspectJAutoProxyCreator就实现了Ordered接口，所以会被加入到orderedPostProcessors中去）</span></span><br></pre></td></tr></table></figure>
<p>​                                源码9</p>
<p>这里ppName=org.springframework.aop.config.internalAutoProxyCreator</p>
<p>然后跟下去， getBean–&gt;doGetBean,  然后来到了如下源码(org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(String, Class<t>, Object[], boolean)中)</t></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line"><span class="comment">// Create bean instance.</span></span><br><span class="line">				<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">					sharedInstance = getSingleton(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">						<span class="meta">@Override</span></span><br><span class="line">						<span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">							<span class="keyword">try</span> &#123;</span><br><span class="line">								<span class="keyword">return</span> createBean(beanName, mbd, args); <span class="comment">// 这里才是真正的创建bean（mbd是bean 定义信息）</span></span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">								<span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">								<span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">								<span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">								destroySingleton(beanName);</span><br><span class="line">								<span class="keyword">throw</span> ex;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;);</span><br><span class="line">					bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">				&#125;</span><br></pre></td></tr></table></figure>
<p>​                                源码10</p>
<p>你看，这里会走第4行,  则跳到如下源码</p>
<p>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(String, ObjectFactory&lt;?&gt;)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">		Assert.notNull(beanName, <span class="string">"'beanName' must not be null"</span>);</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">			Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">			<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationNotAllowedException(beanName,</span><br><span class="line">							<span class="string">"Singleton bean creation not allowed while singletons of this factory are in destruction "</span> +</span><br><span class="line">							<span class="string">"(Do not request a bean from a BeanFactory in a destroy method implementation!)"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(<span class="string">"Creating shared instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				beforeSingletonCreation(beanName);</span><br><span class="line">				<span class="keyword">boolean</span> newSingleton = <span class="keyword">false</span>;</span><br><span class="line">				<span class="keyword">boolean</span> recordSuppressedExceptions = (<span class="keyword">this</span>.suppressedExceptions == <span class="keyword">null</span>);</span><br><span class="line">				<span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">					<span class="keyword">this</span>.suppressedExceptions = <span class="keyword">new</span> LinkedHashSet&lt;Exception&gt;();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					singletonObject = singletonFactory.getObject();</span><br><span class="line">					newSingleton = <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">                ...</span><br><span class="line">                    <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">					addSingleton(beanName, singletonObject);</span><br><span class="line">				&#125;</span><br></pre></td></tr></table></figure>
<p>​                                        源码11</p>
<p>注意第21行. 因为这是第一次进入此代码，所以第4行获取到的一定是null， 则就会走第21行. 而singletonFactory是源码10中的传入的ObjectFactory，所以第21行会回调源码10中的第五行代码（这是典型的回调啊）， 但是源码10中的第7行代码就是createBean了, 也就是既然不存在，我就创建,然后源码11中的第26行就将其加入到singletonObjects中去，以便下次再来的时候就源码11的第5行就不再是null了（这样保证了单实例，即创建好的bean都会被缓存起来）.  所以我们要继续跟进源码10的第七行代码.  createBean–&gt;doCreateBean（注意，之前是getBean–&gt;doGetBean, 现在因为拿不到，改成创建了）  最后来到 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(String, RootBeanDefinition, Object[]). </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize the bean instance.</span></span><br><span class="line">		Object exposedObject = bean;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">			<span class="keyword">if</span> (exposedObject != <span class="keyword">null</span>) &#123;</span><br><span class="line">				exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>​                                        源码12</p>
<p>注释本身就是 “初始化bean实例”.  而源码12的第2行的代码中的bean已经存在了. 所以这里bean是创建，而源码12是对创建的bean进行初始化（populateBean就是干这种事情的,即给bean的各种属性进行赋值）。 而bean的创建代码在源码12的上方一点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">			instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">final</span> Object bean = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedInstance() : <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>​                                        源码13</p>
<p>mbd是bean的定义信息.beanName就是org.springframework.aop.config.internalAutoProxyCreator——这个我们要在源码3的第二步初始化的bean. 现在我们回到源码12的第6行，此时已经创建（源码13）、赋属性值（源码12第四行）完毕了, 现在要做的事情就是initializeBean（其实这就是ioc生成bean的过程，并不仅仅针对bean后置处理器，bean都是 </p>
<p><strong>先注册定义信息-&gt;然后创建-&gt;赋属性值(populateBean)-&gt;initializeBean(后置处理器干活)</strong>）， </p>
<p>这个initializeBean其实特别重要，因为我们的bean后置处理器其实就是在这里面干活的. 所以我们跟进去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					invokeAwareMethods(beanName, bean);</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;, getAccessControlContext());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			invokeAwareMethods(beanName, bean);</span><br><span class="line">		&#125;</span><br><span class="line">    Object wrappedBean = bean;</span><br><span class="line">		<span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">			wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">					(mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">					beanName, <span class="string">"Invocation of init method failed"</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">			wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> wrappedBean;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>​                                        源码14</p>
<p>这里可以看到initializeBean工作的流程.  值得注意的是第12行，invokeAwareMethods方法. 跟进去此方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareMethods</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">			<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanNameAware) &#123;</span><br><span class="line">				((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanClassLoaderAware) &#123;</span><br><span class="line">				((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">				((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="keyword">this</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>​                                        源码15</p>
<p>即如果bean实现了xxxaware接口的话，就会在这里调用相应接口的方法. 因为我们的AnnotationAwareAspectJAutoProxyCreator实现了BeanFactoryAware接口，所以会进入源码15的第10行代码</p>
<p>我们先不着急进入，先看看如果源码14中invokeAwareMethods方法执行完毕之后会干什么. 我们注意到了一个wrappedBean，以及在【2】中就指出的一段源码（这就是BeanPostProcessor 接口的原理）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); <span class="comment">// 拿出所有后置处理器跑一边执行其postProcessorsBeforeInitialization方法</span></span><br><span class="line">...</span><br><span class="line">   invokeInitMethods(beanName, wrappedBean, mbd); <span class="comment">// 执行自定义的init方法.或者PostConstruct方法</span></span><br><span class="line">...</span><br><span class="line">    wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);<span class="comment">// 拿出所有后置处理器跑一边执行其postProcessorsAfterInitialization方法</span></span><br></pre></td></tr></table></figure>
<p>​                                        源码16</p>
<p>所以后置处理器+initMethod方法其实是在xxxAware接口处理之后进行的.</p>
<p>源码16的第一行就是应用后置处理器（BeanPostProcessor）. 它的源码是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsBeforeInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">		Object result = existingBean;</span><br><span class="line">		<span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">			result = beanProcessor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">			<span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> result;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>​                                    源码17</p>
<p>我们可以很清晰的看到，applyBeanPostProcessorsBeforeInitialization方法其实就是拿出所有的后置处理器来跑一边(具体参见【2】). 但是对于AnnotationAwareAspectJAutoProxyCreator而言，目前存在的后置bean处理器全部是spring自带的（一共7个</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[org.springframework.context.support.ApplicationContextAwareProcessor@7f0eb4b4, org.springframework.context.support.ApplicationListenerDetector@19bb089b, org.springframework.context.annotation.ConfigurationClassPostProcessor<span class="formula">$ImportAwareBeanPostProcessor@5c33f1a9, org.springframework.context.support.PostProcessorRegistrationDelegate$</span>BeanPostProcessorChecker@1623b78d, org.springframework.context.annotation.CommonAnnotationBeanPostProcessor@3ce1e309, org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor@6aba2b86, org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor@158da8e]</span><br></pre></td></tr></table></figure>
<p>），所以任何bean创建的流程(即上面提到的initializeBean方法)都是</p>
<p> <strong>xxxAware–&gt;跑后置处理器的postbeforeinitialization方法–&gt;invokeInitMethods(执行InitializingBean接口的afterPropertiesSet方法)–&gt;跑后置处理器的postafterinitializationx方法</strong>.</p>
<p>经过这么漫长的梳理，我们回到源码15的第10行代码, 因为我们要继续讨论以下话题</p>
<h4 id="作为BeanFactoryAware"><a href="#作为BeanFactoryAware" class="headerlink" title="作为BeanFactoryAware"></a>作为BeanFactoryAware</h4><p>源码15的第10行代码将进入源码4, 而源码4第三行将简单的调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.beanFactory = beanFactory;</span><br></pre></td></tr></table></figure>
<p>将beanFactory注入进来, 然后我们来到源码4的第八行.  则再跟进，就来到了</p>
<p>源码5 AnnotationAwareAspectJAutoProxyCreator自己的initBeanFactory方法. 而源码5中做的事情就是创建了aspectJAdvisorsBuilder和aspectJAdvisorFactory.  至此，AnnotationAwareAspectJAutoProxyCreator已经创建完毕，最后我们回到源码9，其最后一行就完成了AnnotationAwareAspectJAutoProxyCreator这个bean后置处理器的注册. 其实所谓的注册就是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			ConfigurableListableBeanFactory beanFactory, List&lt;BeanPostProcessor&gt; postProcessors)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (BeanPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">			beanFactory.addBeanPostProcessor(postProcessor); <span class="comment">// 其实就是将postProcessor加入到org.springframework.beans.factory.support.AbstractBeanFactory.beanPostProcessors（一个ArrayList）</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>​                                    源码18</p>
<p>至此，我们以AnnotationAwareAspectJAutoProxyCreator为例，演示了注册BeanPostProcessor的全过程. 至此，ioc中已经存在了AnnotationAwareAspectJAutoProxyCreator这个bean后置处理器. （最早只是注册此bean的定义）. 下面，只要创建bean，就会被AnnotationAwareAspectJAutoProxyCreator这个bean后置处理器拦截，看看能不能增强(从而完成AOP功能). 这是下面的话题</p>
<h4 id="AnnotationAwareAspectJAutoProxyCreator作为BeanPostProcessor"><a href="#AnnotationAwareAspectJAutoProxyCreator作为BeanPostProcessor" class="headerlink" title="AnnotationAwareAspectJAutoProxyCreator作为BeanPostProcessor"></a>AnnotationAwareAspectJAutoProxyCreator作为BeanPostProcessor</h4><p>至此，我们已经完成了AnnotationAwareAspectJAutoProxyCreator的注册定义+创建的全过程. 下面我们看看这个bean后置处理器将起到什么作用. 回顾之前讲解的initializeBean的过程，现在的AnnotationAwareAspectJAutoProxyCreator已经能参与到任何bean的初始化过程了. 首先，我们的出发点是</p>
<p>源码3中的第三条了，即初始化其他单实例bean. 然后进入到finishBeanFactoryInitialization中的如下源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">		beanFactory.preInstantiateSingletons();</span><br></pre></td></tr></table></figure>
<p>继而进入到preInstantiateSingletons方法中的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">		<span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">            ...</span><br><span class="line">                getBean(beanName);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>目的都是完成剩下的单实例bean（之所以说剩下的是因为前面我们已经初始化了一些单实例bean，例如一些BeanPostProcessor）而这里的beanNames即beanDefinitionNames 在【3】中讲了. 后面就和上面AnnotationAwareAspectJAutoProxyCreator的创建过程一模一样了(就是getBean–&gt;doGetBean 你搜一下”getBean–&gt;doGetBean”前面就知道了). 只是会被AnnotationAwareAspectJAutoProxyCreator拦截. 所以我们在初始化 mathCaculator 的时候，会来到org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.postProcessBeforeInstantiation(Class&lt;?&gt;, String)方法，</p>
<p>等一下!!!! are you kidding me ?</p>
<p>之前不是说好的postProcessBeforeInitialization么(之前说了创建bean的过程中是跑后置处理器的postbeforeinitialization方法)? 怎么现在变成了postProcessBeforeInstantiation了?</p>
<p>不要急，我们看看进入到源码12之前干了什么?</p>
<p>我们来到org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(String, RootBeanDefinition, Object[])</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">			Object bean = resolveBeforeInstantiation(beanName, mbdToUse); <span class="comment">// 这里希望后置处理器能返回一个代理对象，mbdToUse是类的定义信息</span></span><br><span class="line">			<span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123; <span class="comment">// 如果能返回一个代理对象</span></span><br><span class="line">				<span class="keyword">return</span> bean; <span class="comment">// 就返回</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">					<span class="string">"BeanPostProcessor before instantiation of bean failed"</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果第五行不能返回一个代理对象，则走上面AnnotationAwareAspectJAutoProxyCreator的老路，即源码12</span></span><br><span class="line">		Object beanInstance = doCreateBean(beanName, mbdToUse, args); <span class="comment">// 这一行就会进入到源码12</span></span><br></pre></td></tr></table></figure>
<p>​                                                源码19</p>
<p>调用栈显示，我们在上面第三行进入的postProcessBeforeInstantiation方法, 其实我们也可以看到作者已经给出的注释——Give BeanPostProcessors a chance to return a proxy instead of the target bean instance. 即这里给一个机会让直接返回代理，注意第5行的return，而不会再到后面跑postbeforeinitialization方法之后才返回了. 所以这里相当于是拦截了一道. </p>
<p>所以我们可以得到如下结论</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AnnotationAwareAspectJAutoProxyCreator 的作用是可以在真正创建bean（即上面的createBean，你搜一下getBean--&gt;doGetBean就看到了）之前拦截一道，尝试看看能不能为其创建代理返回，如果可以就直接返回了，如果不行，才真正创建bean对象进行注册. 所以对于能生成代理的，ioc容器中存在的根本不是类本身，而是代理.</span><br></pre></td></tr></table></figure>
<p>所以我们的注意力就集中到了源码19的第三行， 即下面的话题</p>
<h4 id="创建代理对象"><a href="#创建代理对象" class="headerlink" title="创建代理对象"></a>创建代理对象</h4><p>继续跟 源码 19 的第三行，我们可以进入到如下源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">resolveBeforeInstantiation</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">		Object bean = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;</span><br><span class="line">			<span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line">			<span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">				Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);</span><br><span class="line">				<span class="keyword">if</span> (targetType != <span class="keyword">null</span>) &#123;</span><br><span class="line">					bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);  <span class="comment">// 先before试一下</span></span><br><span class="line">					<span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123; <span class="comment">// before失败，after就不会再试了</span></span><br><span class="line">						bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			mbd.beforeInstantiationResolved = (bean != <span class="keyword">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> bean; <span class="comment">// before 和after都返回null，最终才返回null</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>​                            源码25</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">applyBeanPostProcessorsBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">				InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">				Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName);</span><br><span class="line">				<span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">return</span> result;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>即遍历所有的后置处理器，如果是 InstantiationAwareBeanPostProcessor 类型的, 则调用其 postProcessBeforeInstantiation 接口方法.而我们之前的AnnotationAwareAspectJAutoProxyCreator这个BeanPostProcessor恰好就是这种类型的. 所以我们来到了如下源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		Object cacheKey = getCacheKey(beanClass, beanName);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (beanName == <span class="keyword">null</span> || !<span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.advisedBeans.containsKey(cacheKey)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;</span><br><span class="line">				<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Create proxy here if we have a custom TargetSource.</span></span><br><span class="line">		<span class="comment">// Suppresses unnecessary default instantiation of the target bean:</span></span><br><span class="line">		<span class="comment">// The TargetSource will handle target instances in a custom fashion.</span></span><br><span class="line">		<span class="keyword">if</span> (beanName != <span class="keyword">null</span>) &#123;</span><br><span class="line">			TargetSource targetSource = getCustomTargetSource(beanClass, beanName);</span><br><span class="line">			<span class="keyword">if</span> (targetSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">this</span>.targetSourcedBeans.add(beanName);</span><br><span class="line">				Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);</span><br><span class="line">				Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);</span><br><span class="line">				<span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">				<span class="keyword">return</span> proxy;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>​                                        源码20</p>
<p>第三行得到bean的名字，beanClass是com.yfs.bean.MathCaculator（即需要增强的bean），第六行中advisedBeans 是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;org.springframework.context.event.internalEventListenerFactory=false, mainConfig=false, org.springframework.context.event.internalEventListenerProcessor=false&#125;</span><br></pre></td></tr></table></figure>
<p>里面是false表明这些bean不需要被增强. 如果cacheKey在这个advisedBeans中的话，显然就不需要增强，就返回null了，则一旦返回null, 增强失败就会老老实实创建bean了(即源码19 的第四行判断). 然后来到第九行，首先判断isInfrastructureClass</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isInfrastructureClass</span><span class="params">(Class&lt;?&gt; beanClass)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">boolean</span> retVal = Advice.class.isAssignableFrom(beanClass) ||</span><br><span class="line">				Pointcut.class.isAssignableFrom(beanClass) ||</span><br><span class="line">				Advisor.class.isAssignableFrom(beanClass) ||</span><br><span class="line">				AopInfrastructureBean.class.isAssignableFrom(beanClass);</span><br><span class="line">		<span class="keyword">if</span> (retVal &amp;&amp; logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">"Did not attempt to auto-proxy infrastructure class ["</span> + beanClass.getName() + <span class="string">"]"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> retVal;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<pre><code>源码21
</code></pre><p>以及（这是子类AnnotationAwareAspectJAutoProxyCreator的实现,实际运行因为现在是AnnotationAwareAspectJAutoProxyCreator，所以一定走的是源码22，只是源码22中有super的调用，所以也会走源码21）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isInfrastructureClass</span><span class="params">(Class&lt;?&gt; beanClass)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">super</span>.isInfrastructureClass(beanClass) || <span class="keyword">this</span>.aspectJAdvisorFactory.isAspect(beanClass));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>​                                    源码22</p>
<p>即问com.yfs.bean.MathCaculator是不是Advice、Pointcut、Advisor、AopInfrastructureBean这些基础class.  以及是不是切面，源码22中的isAspect源码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAspect</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (hasAspectAnnotation(clazz) &amp;&amp; !compiledByAjc(clazz));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasAspectAnnotation</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (AnnotationUtils.findAnnotation(clazz, Aspect.class) != <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>​                                    源码23</p>
<p>可见就是使用AnnotationUtils看看有没有@Aspect注解. 所以切面类也不需要增强的.</p>
<p>如果是的话，则也不需要增强, 并且将这种不需要增强缓存 进 advisedBeans. 再判断是否需要跳过，即shouldSkip（也是AnnotationAwareAspectJAutoProxyCreator的实现）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">shouldSkip</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> Consider optimization by caching the list of the aspect names</span></span><br><span class="line">		List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">		<span class="keyword">for</span> (Advisor advisor : candidateAdvisors) &#123;</span><br><span class="line">			<span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> AspectJPointcutAdvisor) &#123;</span><br><span class="line">				<span class="keyword">if</span> (((AbstractAspectJAdvice) advisor.getAdvice()).getAspectName().equals(beanName)) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.shouldSkip(beanClass, beanName);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>​                                    源码24</p>
<p>第四行获取到增强器（即advisor），什么叫做增强器? 就是我们写在切面LogAspects 中的四个方法， 所以candidateAdvisors 中有4个增强器. 这里遍历这四个增强器做判断，如果是AspectJPointcutAdvisor类型的增强器的话，就可能认定需要跳过. 而我们目前每个增强器的类型是InstantiationModelAwarePointcutAdvisor，不是AspectJPointcutAdvisor类型的. 所以上面的遍历都是false的. 而super对shouldSkip 的实现异常简单，就是返回false. 所以源码24返回的就是false.所以回到源码20，能够来到第18行. beanName是mathCaculator，而源码20的targetSource依旧是null，则源码20返回null.  即源码25 中的 postProcessBeforeInstantiation返回null了，所以我们根据源码25的思路就不会尝试postProcessAfterInstantiation，（此时其实我是有点失落的~ 难道不应该在源码19 的第五行解决战斗吗? ）则会进入到源码19的第13行老老实实创建bean（doCreateBean）, 而doCreateBean的过程中就会调用 AnnotationAwareAspectJAutoProxyCreator的 postProcessBeforeInstantiation、postProcessAfterInitialization方法(其实是调用它的父类AbstractAutoProxyCreator的这两个方法). 而postProcessBeforeInitialization是平凡的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>所以我们注意力集中在postProcessAfterInitialization，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a proxy with the configured interceptors if the bean is</span></span><br><span class="line"><span class="comment">	 * identified as one to proxy by the subclass.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getAdvicesAndAdvisorsForBean</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">			Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">			<span class="keyword">if</span> (!<span class="keyword">this</span>.earlyProxyReferences.contains(cacheKey)) &#123;</span><br><span class="line">				<span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>​                                            源码26</p>
<p>注释也写得很明白——此方法的目的是创建代理对象返回. 注意，上面源码26的bean已经不是null了(因为已经创建并赋属性值了甚至aware接口也处理完毕了，现在是跑bean后置处理器). cacheKey自然是mathCaculator. 然后返回一个包装类. 即进入到源码的第11行.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (beanName != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">			<span class="keyword">return</span> bean;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">			<span class="keyword">return</span> bean;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">			<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">			<span class="keyword">return</span> bean;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Create proxy if we have advice.</span></span><br><span class="line">		Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line">		<span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">			<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">			Object proxy = createProxy(</span><br><span class="line">					bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">			<span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">			<span class="keyword">return</span> proxy;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>​                                    源码27</p>
<p>直接跳到源码27的第14行. 注释写的很明确——如果有能用于此bean的通知方法（即getAdvicesAndAdvisorsForBean方法，就不跟进去了，这里面涉及到使用@Pointcut表达式计算是否匹配，并且还对 增强器做了排序），就创建代理.</p>
<p>显然我们有四个（因为切面类LogAspects中有4个通知方法）. 然后advisedBeans中加入了cacheKey=mathCaculator需要增强的信息, 并且来到了关键的第17行代码——这一行代码才是真正创建代理类的. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">			AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="keyword">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">		proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">				proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">		proxyFactory.addAdvisors(advisors);</span><br><span class="line">		proxyFactory.setTargetSource(targetSource);</span><br><span class="line">		customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">		proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line">		<span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">			proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>​                                源码28</p>
<p>proxyFactory是创建代理的工厂,它里面保存了适用于bean的增强器, 主要看最后一行，继续跟</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> createAopProxy().getProxy(classLoader);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title">createAopProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.active) &#123;</span><br><span class="line">			activate();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">			Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">			<span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line">						<span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>可见，一个是JdkDynamicAopProxy一个是ObjenesisCglibAopProxy（即一个是jdk的动态代理，一个是cglib的动态代理）</p>
<p>具体是哪个，由Spring决定.  一般如果实现了接口，则使用前者，否则使用后者. 因为我们的DEMO【1】中没有实现接口，所以返回的是cglib增强的动态代理. 回到源码27， 第17行的proxy就是cglib增强的动态代理. 而且我们返回的也是这个动态代理. 所以最后注册到ioc中的就是代理对象. 即ioc容器中获取到的也是这种代理对象而不是对象本身.   </p>
<p>注意，这里有必要讲一下最后返回的增强对象(即源码28下面的第一个源码的第二行)到底长什么样子(即最后的MathCaculator\$\$EnhancerBySpringCGLIB对象到底长什么样子)</p>
<img src="/2019/06/13/spring-AOP-注解原理/1.png">
<p>​                                图1</p>
<p>可以看出，MathCaculator\$\$EnhancerBySpringCGLIB就是一堆的拦截器链. 这些拦截器链是在源码28下的第一个源码的第二行的getProxy时做的. 具体源码就不跟了 ，反正你要知道，放进ioc中的增强后的对象其实和原本的MathCalculator没一毛钱关系，它其实就是一堆的cglib拦截器链.</p>
<p>wait,wait,wait, 这里我们关心一下我们使用spring的时候一直谈论但是其实很多人并不清楚的两个问题</p>
<ol>
<li>ioc容器到底是什么?</li>
<li>注入bean（注意，注册和注入是不一样的，注册是注册bean的定义(添加到【3】中获取的beanDefinitionNames中去)，而注入是将创建好的bean放进ioc容器中去）到底是啥?</li>
</ol>
<p>从源码26的第11行创建增强bean返回之后，一路返回，返回到源码11的第21行.  然后源码11的第26行，就是将源码11的第21行得到的singletonObject加入到org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.singletonObjects中去. </p>
<p>这个singletonObjects属性（一个ConcurrentHashMap&lt;String, Object&gt;(256)）就是我们天天谈论的ioc容器.</p>
<p>后面你会看到，我们取bean的时候也是从这个singletonObjects中取的.</p>
<p>所以我们继续关心下一个话题</p>
<h4 id="从IOC容器中获取bean的流程"><a href="#从IOC容器中获取bean的流程" class="headerlink" title="从IOC容器中获取bean的流程"></a>从IOC容器中获取bean的流程</h4><p>上一节我们已经知道了注入到ioc中的是代理对象. 现在考虑代理对象上调用目标方法.</p>
<p>不过，在此之前，我们先说清楚是怎么从ioc容器中取得bean的.</p>
<p>还是以demo【1】为例.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MathCaculator mathCaculator = applicationContext.getBean(MathCaculator.class);</span><br></pre></td></tr></table></figure>
<p>这一行代码就是我们从ioc容器中获取MathCaculator类型的bean. 跟进源码会来到</p>
<p>org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(Class<t>, Object…)(其实正因为如此，)</t></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		NamedBeanHolder&lt;T&gt; namedBean = resolveNamedBean(requiredType, args);</span><br><span class="line">		<span class="keyword">if</span> (namedBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> namedBean.getBeanInstance();</span><br><span class="line">		&#125;</span><br><span class="line">		BeanFactory parent = getParentBeanFactory();</span><br><span class="line">		<span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> parent.getBean(requiredType, args);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(requiredType);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>​                                    源码29</p>
<p>会在源码29的第5行返回. 跟进源码29的第三行.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">	<span class="keyword">private</span> &lt;T&gt; <span class="function">NamedBeanHolder&lt;T&gt; <span class="title">resolveNamedBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		Assert.notNull(requiredType, <span class="string">"Required type must not be null"</span>);</span><br><span class="line">		String[] candidateNames = getBeanNamesForType(requiredType);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (candidateNames.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			List&lt;String&gt; autowireCandidates = <span class="keyword">new</span> ArrayList&lt;String&gt;(candidateNames.length);</span><br><span class="line">			<span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!containsBeanDefinition(beanName) || getBeanDefinition(beanName).isAutowireCandidate()) &#123;</span><br><span class="line">					autowireCandidates.add(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!autowireCandidates.isEmpty()) &#123;</span><br><span class="line">				candidateNames = autowireCandidates.toArray(<span class="keyword">new</span> String[autowireCandidates.size()]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (candidateNames.length == <span class="number">1</span>) &#123;</span><br><span class="line">			String beanName = candidateNames[<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> NamedBeanHolder&lt;T&gt;(beanName, getBean(beanName, requiredType, args));</span><br><span class="line">		&#125;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<p>​                                        源码30</p>
<p>源码30的第18行的candidateNames长度是1，就只有一个mathCaculator，所以跟进源码30第20行的getBean方法. 继续跟进doGetBean，来到了</p>
<p>org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(String, Class<t>, Object[], boolean)</t></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">	<span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">final</span> String name, <span class="keyword">final</span> Class&lt;T&gt; requiredType, <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">		Object bean;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">		Object sharedInstance = getSingleton(beanName);</span><br><span class="line">		<span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>
<p>​                                    源码31</p>
<p>这其实就是源码10上面打省略号的部分. 这里第10行获取sharedInstance不再为null了，所以不会走源码10.  跟进源码31的第10行. 我们来到了org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(String, boolean)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">		Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">		<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>
<p>​                                    源码32</p>
<p>第二行就是从singletonObjects获取到非null的singletonObject（就是一个MathCaculator$$EnhancerBySpringCGLIB 对象）. 所以直接返回，而不会走下面了.</p>
<p>于是返回源码29的第五行，最终App.main 中从容器中获取的就是一个MathCaculator\$\$EnhancerBySpringCGLIB对象. 所以讲清楚这个问题之后，我们来看看调用MathCaculator$$EnhancerBySpringCGLIB的div方法（即目标方法）的过程.</p>
<h4 id="增强对象调用目标方法的流程"><a href="#增强对象调用目标方法的流程" class="headerlink" title="增强对象调用目标方法的流程"></a>增强对象调用目标方法的流程</h4><p>调用目标方法的时候debug进入到org.springframework.aop.framework.CglibAopProxy.DynamicAdvisedInterceptor.intercept(Object, Method, Object[], MethodProxy)方法, 此方法从名称上也能看出来是拦截一下目标方法, 注意，之前我们说了MathCaculator\$\$EnhancerBySpringCGLIB对象其实就是一堆的cglib拦截器链，这里正好就是图1的第一个拦截器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass); <span class="comment">// 获取拦截器链</span></span><br><span class="line">				Object retVal;</span><br><span class="line">				<span class="comment">// Check whether we only have one InvokerInterceptor: that is,</span></span><br><span class="line">				<span class="comment">// no real advice, but just reflective invocation of the target.</span></span><br><span class="line">				<span class="keyword">if</span> (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">					<span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly.</span></span><br><span class="line">					<span class="comment">// Note that the final invoker must be an InvokerInterceptor, so we know</span></span><br><span class="line">					<span class="comment">// it does nothing but a reflective operation on the target, and no hot</span></span><br><span class="line">					<span class="comment">// swapping or fancy proxying.</span></span><br><span class="line">					Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">					retVal = methodProxy.invoke(target, argsToUse);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// We need to create a method invocation...</span></span><br><span class="line">					retVal = <span class="keyword">new</span> CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();</span><br><span class="line">				&#125;</span><br><span class="line">				retVal = processReturnType(proxy, target, method, retVal);</span><br><span class="line">				<span class="keyword">return</span> retVal;</span><br></pre></td></tr></table></figure>
<p>​                                源码33</p>
<p>源码33其实就是获取拦截器链，获取谁的拦截器链呢? </p>
<p>method=public int com.yfs.bean.MathCaculator.div(int,int)</p>
<p>targetClass=class com.yfs.bean.MathCaculator</p>
<p>target=com.yfs.bean.MathCaculator@338c99c8</p>
<p>advised就是一个ProxyFactory</p>
<p>即获取method（目标方法）的拦截器链.</p>
<p>从上面的官方注释也可以看出——如果没有拦截器链（拦截器链为空），则直接执行目标方法，否则把目标对象、目标方法、拦截器链等信息创建一个CglibMethodInvocation对象（简称mi），并且执行mi.proceed() 方法（因为CglibMethodInvocation中包含了拦截器链，所以其实proceed方法就是触发整个拦截器链）.得到的结果retVal，再进一步对retVal进行处理（即processReturnType）</p>
<p>这是大体流程，而且我们能猜测到这个拦截器链非常重要——它应该包含了通知方法. 所以我们要考察一下拦截器链是怎么获取的. 跟进源码33的第二行源码</p>
<p>org.springframework.aop.framework.AdvisedSupport.getInterceptorsAndDynamicInterceptionAdvice(Method, Class&lt;?&gt;)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getInterceptorsAndDynamicInterceptionAdvice</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">		MethodCacheKey cacheKey = <span class="keyword">new</span> MethodCacheKey(method);</span><br><span class="line">		List&lt;Object&gt; cached = <span class="keyword">this</span>.methodCache.get(cacheKey);</span><br><span class="line">		<span class="keyword">if</span> (cached == <span class="keyword">null</span>) &#123;</span><br><span class="line">			cached = <span class="keyword">this</span>.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(</span><br><span class="line">					<span class="keyword">this</span>, method, targetClass);</span><br><span class="line">			<span class="keyword">this</span>.methodCache.put(cacheKey, cached);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> cached;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>​                                                源码34</p>
<p>对于第一次进来，第四行一定是null，则跟进源码34的第五行,我们来到DefaultAdvisorChainFactory的getInterceptorsAndDynamicInterceptionAdvice方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; interceptorList = <span class="keyword">new</span> ArrayList&lt;Object&gt;(config.getAdvisors().length);</span><br><span class="line">		Class&lt;?&gt; actualClass = (targetClass != <span class="keyword">null</span> ? targetClass : method.getDeclaringClass());</span><br><span class="line">		<span class="keyword">boolean</span> hasIntroductions = hasMatchingIntroductions(config, actualClass);</span><br><span class="line">		AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (Advisor advisor : config.getAdvisors()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> PointcutAdvisor) &#123;</span><br><span class="line">				<span class="comment">// Add it conditionally.</span></span><br><span class="line">				PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;</span><br><span class="line">				<span class="keyword">if</span> (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">					MethodInterceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">					MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();</span><br><span class="line">					<span class="keyword">if</span> (MethodMatchers.matches(mm, method, actualClass, hasIntroductions)) &#123;</span><br><span class="line">						<span class="keyword">if</span> (mm.isRuntime()) &#123;</span><br><span class="line">							<span class="comment">// Creating a new object instance in the getInterceptors() method</span></span><br><span class="line">							<span class="comment">// isn't a problem as we normally cache created chains.</span></span><br><span class="line">							<span class="keyword">for</span> (MethodInterceptor interceptor : interceptors) &#123;</span><br><span class="line">								interceptorList.add(<span class="keyword">new</span> InterceptorAndDynamicMethodMatcher(interceptor, mm));</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span> &#123;</span><br><span class="line">							interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line">				IntroductionAdvisor ia = (IntroductionAdvisor) advisor;</span><br><span class="line">				<span class="keyword">if</span> (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">					Interceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">					interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				Interceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">				interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> interceptorList;  <span class="comment">// 就是要返回的拦截器链</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>​                                    源码35</p>
<p>源码35中的config.getAdvisors()得到的就是4个通知方法. 遍历这些通知方法（InstantiationModelAwarePointcutAdvisor类型）封装成MethodInterceptor[](源码35的第11行——MethodInterceptor[] interceptors = registry.getInterceptors(advisor); 转换的过程就是判断是不是MethodInterceptor, 如果是，则直接加入，如果不是，找一堆的适配器（[org.springframework.aop.framework.adapter.MethodBeforeAdviceAdapter, org.springframework.aop.framework.adapter.AfterReturningAdviceAdapter, org.springframework.aop.framework.adapter.ThrowsAdviceAdapter]，也就是这三种通知需要转为MethodInterceptor）将其转换为MethodInterceptor后加进去), 最后加入到要返回的interceptorList中去.</p>
<p>所以，所谓的拦截器链其实就是通知方法被转换为MethodInterceptor接口组成的链表，然后都是MethodInterceptor在执行。下面我们看看拦截器链长什么样子</p>
<img src="/2019/06/13/spring-AOP-注解原理/2.png">
<p>​                                            图2</p>
<h4 id="拦截器链如何执行"><a href="#拦截器链如何执行" class="headerlink" title="拦截器链如何执行"></a>拦截器链如何执行</h4><p>上一节我们最后得到的结论是将拦截器链封装进了一个mi（MethodInvocation，具体就是CglibMethodInvocation，你可以理解其为方法执行链上下文）. 然后调用该mi的proceed方法. 这个proceed方法将触发拦截器链的调用.本节我们谈谈触发的流程以及包含的设计模式.</p>
<p>我们回到源码33的第16行. 即CglibMethodInvocation调用其proceed方法. 注意CglibMethodInvocation是ReflectiveMethodInvocation的子类，其实是调用ReflectiveMethodInvocation的proceed方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="comment">//	We start with an index of -1 and increment early.</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> invokeJoinpoint(); <span class="comment">// 反射执行目标方法</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Object interceptorOrInterceptionAdvice =</span><br><span class="line">				<span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);<span class="comment">// 获取当前拦截器链中的拦截器</span></span><br><span class="line">		<span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">			<span class="comment">// Evaluate dynamic method matcher here: static part will already have</span></span><br><span class="line">			<span class="comment">// been evaluated and found to match.</span></span><br><span class="line">			InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">					(InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">			<span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, <span class="keyword">this</span>.targetClass, <span class="keyword">this</span>.arguments)) &#123;</span><br><span class="line">				<span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// Dynamic matching failed.</span></span><br><span class="line">				<span class="comment">// Skip this interceptor and invoke the next in the chain.</span></span><br><span class="line">				<span class="keyword">return</span> proceed();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="comment">// 上面的if不会走</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// It's an interceptor, so we just invoke it: The pointcut will have</span></span><br><span class="line">			<span class="comment">// been evaluated statically before this object was constructed.</span></span><br><span class="line">			<span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>); <span class="comment">// 责任链设计模式</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>​                                            源码36</p>
<p>上述源码就是经典的责任链设计模式. 对应【4】进行查看. 唯一需要注意的是，这里是逆序调用拦截器链中的各个拦截器的.  因为源码36的第27行依次进入的源码是</p>
<p>ExposeInvocationInterceptor.invoke</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		MethodInvocation oldInvocation = invocation.get();</span><br><span class="line">		invocation.set(mi);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> mi.proceed();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			invocation.set(oldInvocation);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>​                                    源码37</p>
<p>AspectJAfterThrowingAdvice.invoke</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> mi.proceed();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123; <span class="comment">// 捕捉 源码39、40、41中的异常,如果没有异常，则不会执行throwing方法</span></span><br><span class="line">			<span class="keyword">if</span> (shouldInvokeOnThrowing(ex)) &#123;</span><br><span class="line">				invokeAdviceMethod(getJoinPointMatch(), <span class="keyword">null</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">throw</span> ex; <span class="comment">// 往上抛</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>​                                    源码38</p>
<p>AfterReturningAdviceInterceptor.invoke</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		Object retVal = mi.proceed(); <span class="comment">// 源码40、41遇到了异常的话，是不会执行returning的切面方法的</span></span><br><span class="line">		<span class="keyword">this</span>.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());</span><br><span class="line">		<span class="keyword">return</span> retVal;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>​                                    源码39</p>
<p>AspectJAfterAdvice.invoke</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> mi.proceed();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			invokeAdviceMethod(getJoinPointMatch(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>​                                    源码40</p>
<p>MethodBeforeAdviceInterceptor.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis() );</span><br><span class="line">		<span class="keyword">return</span> mi.proceed();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>​                                    源码41</p>
<p>注意源码41，即最后进入的拦截器，是先调用通知方法再proceed. 而回到源码36第4行的话，满足第四行条件，就执行源码36第5行了, 即反射调用目标方法.  然后逐层退出. 因此我们知道了整个拦截器栈（因为逆序，所以用栈其实更合适）的执行过程是</p>
<p><strong>before–&gt;目标方法–&gt;after–&gt;afterreturning(正常)/afterthrowing(异常)–&gt;重新设置回原先的MethodInvocation</strong></p>
<p>所以与拦截器chains这根链表中的顺序恰好相反. 所以叫拦截器栈更为合适，而不是叫拦截器链.</p>
<p>至此，我们就弄清楚了Spring AOP 的所有原理. </p>
<h3 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h3><p>【1】<a href="https://github.com/yfsyfs/backend/tree/master/spring-annotation-aop" target="_blank" rel="noopener">https://github.com/yfsyfs/backend/tree/master/spring-annotation-aop</a> </p>
<p>【2】<a href="https://yfsyfs.github.io/2019/06/10/BeanPostProcessor-%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/" target="_blank" rel="noopener">https://yfsyfs.github.io/2019/06/10/BeanPostProcessor-%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</a> </p>
<p>【3】<a href="https://yfsyfs.github.io/2019/06/13/Profile-%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">https://yfsyfs.github.io/2019/06/13/Profile-%E5%8E%9F%E7%90%86/</a>  </p>
<p>【4】<a href="https://yfsyfs.github.io/2019/06/14/Spring-AOP-%E4%B8%AD%E7%9A%84%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">https://yfsyfs.github.io/2019/06/14/Spring-AOP-%E4%B8%AD%E7%9A%84%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</a> </p>

          <div id="vcomments"></div>
          <script>
            new Valine({
              el: '#vcomments' ,
              appId: 'XlY58twgvIOmA3HxDHid3qxr-gzGzoHsz',
              appKey: 'XPVIq9oMfocEh6gcBmLadxCb',
              notify:false,
              verify:false,
              avatar:'mp',
              placeholder: '请奉上您的真知灼见, 谢谢!'
            });
          </script>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/13/spring-AOP-注解原理/" data-id="ck19y0xz502rcx4vmucvxz30e" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/">Spring</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后端/">后端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/06/13/oauth2-0-协议简记/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          oauth2.0 协议简记
        
      </div>
    </a>
  
  
    <a href="/2019/06/13/Profile-原理/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">@Profile 原理</div>
    </a>
  
</nav>

  
</article>



</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/01背包/">01背包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/51nod/">51nod</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/A-算法/">A*算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BST/">BST</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-Primer/">C++ Primer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CRT/">CRT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C和指针/">C和指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DAG/">DAG</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DFS/">DFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DLX/">DLX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DP/">DP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dirac定理/">Dirac定理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/EK/">EK</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FFT/">FFT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ford-Fulkerson/">Ford-Fulkerson</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hadoop/">Hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HotSpot/">HotSpot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Huffman树/">Huffman树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDA/">IDA*</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JDK/">JDK</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JMM/">JMM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JRE/">JRE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Johnson不等式/">Johnson不等式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/KMP/">KMP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LCA/">LCA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LCS/">LCS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LDAP/">LDAP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LIS/">LIS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MST/">MST</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Manacher算法/">Manacher算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Miller-Rabin/">Miller-Rabin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Oauth2-0/">Oauth2.0</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenJudge/">OpenJudge</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pollard-rho/">Pollard rho</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RMQ/">RMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ST/">ST</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SVN/">SVN</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/String/">String</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tarjan/">Tarjan</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/activemq/">activemq</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ai/">ai</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ball树/">ball树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bcc/">bcc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bfs/">bfs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bfs搜索带权图可行未必最短路径/">bfs搜索带权图可行未必最短路径</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-c/">c/c++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cf/">cf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dfs/">dfs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dfs找一条路径找到就不玩了则不需要改回来/">dfs找一条路径找到就不玩了则不需要改回来</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dijkstra/">dijkstra</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dp/">dp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/fft/">fft</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/fleury/">fleury</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/floyd/">floyd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/fzu/">fzu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gabow/">gabow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gcd/">gcd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gcj/">gcj</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gradle/">gradle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hadoop/">hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hdfs/">hdfs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hdu/">hdu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hibernate/">hibernate</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hihocoder/">hihocoder</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hustoj/">hustoj</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java并发编程实践/">java并发编程实践</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jdbc/">jdbc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jpa/">jpa</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/karatsuba/">karatsuba</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kasaraju/">kasaraju</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kd树/">kd树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kmp/">kmp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/knn/">knn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kruskal/">kruskal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kth/">kth</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/">leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/libreoj/">libreoj</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lightoj/">lightoj</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/makedata/">makedata</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mapreduce/">mapreduce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/md数学公式对齐/">md数学公式对齐</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/miller-rabin/">miller-rabin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/next-permutation/">next_permutation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/">node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nth-element/">nth_element</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oj/">oj</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oracle/">oracle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pair的用法/">pair的用法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/poj/">poj</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pollard-rho/">pollard-rho</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/postgresql/">postgresql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/prim/">prim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sap/">sap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sbt/">sbt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scc/">scc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sdutoj/">sdutoj</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/servlet/">servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sjtuoj/">sjtuoj</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spfa/">spfa</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spoj/">spoj</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springboot/">springboot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springmvc/">springmvc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql/">sql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sscanf/">sscanf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sstream/">sstream</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stringstream/">stringstream</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swagger/">swagger</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/synchronized/">synchronized</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tarjan/">tarjan</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/topK/">topK</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/treap/">treap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/trie/">trie</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tsp/">tsp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/uoj/">uoj</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/uva/">uva</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vector初始化容量/">vector初始化容量</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/volatile/">volatile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/zoj/">zoj</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/zzuli/">zzuli</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/zzulioj/">zzulioj</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/三分/">三分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/中位数/">中位数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/中国剩余定理/">中国剩余定理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/事务/">事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二分/">二分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二分图/">二分图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二分查找/">二分查找</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二分答案/">二分答案</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二叉树/">二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二进制状态压缩/">二进制状态压缩</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/交叉染色/">交叉染色</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/交叉染色法/">交叉染色法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/优先队列/">优先队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/传递闭包/">传递闭包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/位图/">位图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/全排列/">全排列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内存模型/">内存模型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内部排序/">内部排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分块矩阵快速幂/">分块矩阵快速幂</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分支限界/">分支限界</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分治/">分治</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分解素因数/">分解素因数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/划分数/">划分数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/剑指offer/">剑指offer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/剪枝/">剪枝</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/割点/">割点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/割边/">割边</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动态查找/">动态查找</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动态规划/">动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/区间DP/">区间DP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/单向连通/">单向连通</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/单纯形法/">单纯形法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/单调子序列/">单调子序列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/单调队列/">单调队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/卡塔兰数/">卡塔兰数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/卡米切尔数/">卡米切尔数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/原生js/">原生js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/双向bfs/">双向bfs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/反向建图/">反向建图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/反转开关问题/">反转开关问题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/同步/">同步</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后台/">后台</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后端/">后端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后端，数据库-mysql/">后端，数据库, mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后缀树/">后缀树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/启发式搜索/">启发式搜索</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/哈密顿回路/">哈密顿回路</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/哈希/">哈希</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/回归/">回归</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/回文/">回文</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/回溯/">回溯</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图/">图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/在线算法/">在线算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/坐标离散化/">坐标离散化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/块/">块</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/堆/">堆</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/堆优化/">堆优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/堆排/">堆排</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/堆排序/">堆排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/外部排序/">外部排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多源多汇/">多源多汇</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多重背包/">多重背包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多重集组合数/">多重集组合数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/大数据/">大数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字典序最小/">字典序最小</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字符串/">字符串</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字符串匹配/">字符串匹配</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/完全背包/">完全背包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/宽搜/">宽搜</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/小程序/">小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/尺取法/">尺取法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/左式堆/">左式堆</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/带括号带逗号的恶心输入/">带括号带逗号的恶心输入</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/带权并查集/">带权并查集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/平方分割/">平方分割</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/平衡查找树/">平衡查找树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/平面最近点对/">平面最近点对</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/并发/">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/并查集/">并查集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/康托展开/">康托展开</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/弹性碰撞/">弹性碰撞</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/强连通/">强连通</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/强连通分支/">强连通分支</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/归并排序/">归并排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/归并树/">归并树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/心语/">心语</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/快排/">快排</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/快速幂/">快速幂</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/性能优化/">性能优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/感悟/">感悟</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/手工扩栈/">手工扩栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/扩展KMP/">扩展KMP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/扩展欧几里得/">扩展欧几里得</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/抓包/">抓包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/折半枚举/">折半枚举</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/拆点/">拆点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/拓扑排序/">拓扑排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/排序/">排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/搜索/">搜索</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/操作系统/">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/教材/">教材</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数学/">数学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数组/">数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数论/">数论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/方差优化/">方差优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/暴力/">暴力</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最大公约数/">最大公约数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最大流/">最大流</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最大流算法的优化/">最大流算法的优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最大流算法重弧和自环和反向平行弧不会影响算法的正确性而只会影响效率/">最大流算法重弧和自环和反向平行弧不会影响算法的正确性而只会影响效率</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最大生成树/">最大生成树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最小正整数解/">最小正整数解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最小生成树/">最小生成树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最短路/">最短路</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最短路径/">最短路径</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最长回文子串/">最长回文子串</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/有向图/">有向图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/机器学习/">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/杂/">杂</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/板子/">板子</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/查找/">查找</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/查找树/">查找树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/栈/">栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树/">树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树堆/">树堆</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树形dp/">树形dp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树排/">树排</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树状数组/">树状数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树的直径/">树的直径</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/桶排序/">桶排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模块化/">模块化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模拟/">模拟</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模拟退火/">模拟退火</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模板/">模板</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/次短路/">次短路</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/欧几里得/">欧几里得</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/欧拉函数/">欧拉函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/欧拉回路/">欧拉回路</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/欧拉环游/">欧拉环游</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/欧拉环路/">欧拉环路</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/死锁/">死锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/泛洪/">泛洪</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/洛谷/">洛谷</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/洪特规则/">洪特规则</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浮点数二分答案/">浮点数二分答案</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/深搜/">深搜</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码/">源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码分析/">源码分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/滚动数组/">滚动数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/版本控制/">版本控制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/牛客网/">牛客网</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/牛顿迭代法/">牛顿迭代法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/状态压缩/">状态压缩</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/状态压缩DP/">状态压缩DP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/生成树/">生成树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/百练/">百练</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/矩阵快速幂/">矩阵快速幂</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/离散化/">离散化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/空间复杂度优化/">空间复杂度优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/筛法/">筛法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/简历/">简历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/精确匹配/">精确匹配</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/精确覆盖/">精确覆盖</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/素数/">素数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/素数测试/">素数测试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/约瑟夫环/">约瑟夫环</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线上问题/">线上问题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线性同余方程/">线性同余方程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线性筛/">线性筛</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线性规划/">线性规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线段树/">线段树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/组件化/">组件化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编译原理/">编译原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/缩点/">缩点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/缩点重构DAG/">缩点重构DAG</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络协议/">网络协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络流/">网络流</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络流建图/">网络流建图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/背包/">背包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/胜者树/">胜者树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/自己动手用java写编译器/">自己动手用java写编译器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/菜鸟教材/">菜鸟教材</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/蓝桥杯/">蓝桥杯</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算几何/">计算几何</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/记忆化搜索/">记忆化搜索</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/词典/">词典</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/负权环/">负权环</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/败者树/">败者树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/贪心/">贪心</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/轮播图/">轮播图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/输出方案/">输出方案</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/边bcc/">边bcc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/连通/">连通</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/连通分支/">连通分支</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/连通性/">连通性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/逆元/">逆元</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/逆序数/">逆序数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/递归/">递归</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/递归转栈/">递归转栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/遍历/">遍历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/邻接多重表/">邻接多重表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/邻接链表法/">邻接链表法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/重复覆盖/">重复覆盖</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/链表/">链表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/锁/">锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/队列/">队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/集合/">集合</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/静态查找树/">静态查找树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/非递归/">非递归</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面试/">面试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/马踏棋盘/">马踏棋盘</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/高精度/">高精度</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/01背包/" style="font-size: 12.41px;">01背包</a> <a href="/tags/51nod/" style="font-size: 10px;">51nod</a> <a href="/tags/A-算法/" style="font-size: 10px;">A*算法</a> <a href="/tags/BST/" style="font-size: 10px;">BST</a> <a href="/tags/C/" style="font-size: 17.59px;">C</a> <a href="/tags/C/" style="font-size: 11.03px;">C++</a> <a href="/tags/C-Primer/" style="font-size: 10px;">C++ Primer</a> <a href="/tags/CRT/" style="font-size: 10px;">CRT</a> <a href="/tags/C和指针/" style="font-size: 17.24px;">C和指针</a> <a href="/tags/DAG/" style="font-size: 11.38px;">DAG</a> <a href="/tags/DFS/" style="font-size: 10.34px;">DFS</a> <a href="/tags/DLX/" style="font-size: 11.72px;">DLX</a> <a href="/tags/DP/" style="font-size: 16.55px;">DP</a> <a href="/tags/Dirac定理/" style="font-size: 10px;">Dirac定理</a> <a href="/tags/EK/" style="font-size: 12.07px;">EK</a> <a href="/tags/FFT/" style="font-size: 10px;">FFT</a> <a href="/tags/Ford-Fulkerson/" style="font-size: 10px;">Ford-Fulkerson</a> <a href="/tags/Hadoop/" style="font-size: 10px;">Hadoop</a> <a href="/tags/HotSpot/" style="font-size: 10px;">HotSpot</a> <a href="/tags/Huffman树/" style="font-size: 10px;">Huffman树</a> <a href="/tags/IDA/" style="font-size: 10.69px;">IDA*</a> <a href="/tags/JDK/" style="font-size: 16.21px;">JDK</a> <a href="/tags/JMM/" style="font-size: 10.34px;">JMM</a> <a href="/tags/JRE/" style="font-size: 10px;">JRE</a> <a href="/tags/JVM/" style="font-size: 10.69px;">JVM</a> <a href="/tags/Johnson不等式/" style="font-size: 10px;">Johnson不等式</a> <a href="/tags/KMP/" style="font-size: 10px;">KMP</a> <a href="/tags/LCA/" style="font-size: 10.69px;">LCA</a> <a href="/tags/LCS/" style="font-size: 10.34px;">LCS</a> <a href="/tags/LDAP/" style="font-size: 10.34px;">LDAP</a> <a href="/tags/LIS/" style="font-size: 11.03px;">LIS</a> <a href="/tags/MST/" style="font-size: 10.69px;">MST</a> <a href="/tags/Manacher算法/" style="font-size: 10px;">Manacher算法</a> <a href="/tags/Miller-Rabin/" style="font-size: 10.69px;">Miller-Rabin</a> <a href="/tags/Oauth2-0/" style="font-size: 10px;">Oauth2.0</a> <a href="/tags/OpenJudge/" style="font-size: 10px;">OpenJudge</a> <a href="/tags/Pollard-rho/" style="font-size: 10.34px;">Pollard rho</a> <a href="/tags/RMQ/" style="font-size: 11.72px;">RMQ</a> <a href="/tags/ST/" style="font-size: 10px;">ST</a> <a href="/tags/SVN/" style="font-size: 10px;">SVN</a> <a href="/tags/Spring/" style="font-size: 14.14px;">Spring</a> <a href="/tags/String/" style="font-size: 10.34px;">String</a> <a href="/tags/Tarjan/" style="font-size: 10px;">Tarjan</a> <a href="/tags/activemq/" style="font-size: 10px;">activemq</a> <a href="/tags/ai/" style="font-size: 10.34px;">ai</a> <a href="/tags/ball树/" style="font-size: 10px;">ball树</a> <a href="/tags/bcc/" style="font-size: 10px;">bcc</a> <a href="/tags/bfs/" style="font-size: 13.1px;">bfs</a> <a href="/tags/bfs搜索带权图可行未必最短路径/" style="font-size: 10px;">bfs搜索带权图可行未必最短路径</a> <a href="/tags/c-c/" style="font-size: 10px;">c/c++</a> <a href="/tags/cf/" style="font-size: 10px;">cf</a> <a href="/tags/dfs/" style="font-size: 15.17px;">dfs</a> <a href="/tags/dfs找一条路径找到就不玩了则不需要改回来/" style="font-size: 10px;">dfs找一条路径找到就不玩了则不需要改回来</a> <a href="/tags/dijkstra/" style="font-size: 11.38px;">dijkstra</a> <a href="/tags/dp/" style="font-size: 14.83px;">dp</a> <a href="/tags/fft/" style="font-size: 10px;">fft</a> <a href="/tags/fleury/" style="font-size: 11.72px;">fleury</a> <a href="/tags/floyd/" style="font-size: 11.38px;">floyd</a> <a href="/tags/fzu/" style="font-size: 10.69px;">fzu</a> <a href="/tags/gabow/" style="font-size: 10px;">gabow</a> <a href="/tags/gcd/" style="font-size: 10.69px;">gcd</a> <a href="/tags/gcj/" style="font-size: 10px;">gcj</a> <a href="/tags/gradle/" style="font-size: 10.34px;">gradle</a> <a href="/tags/hadoop/" style="font-size: 10.34px;">hadoop</a> <a href="/tags/hdfs/" style="font-size: 10.34px;">hdfs</a> <a href="/tags/hdu/" style="font-size: 17.93px;">hdu</a> <a href="/tags/hibernate/" style="font-size: 10px;">hibernate</a> <a href="/tags/hihocoder/" style="font-size: 10.34px;">hihocoder</a> <a href="/tags/hustoj/" style="font-size: 10px;">hustoj</a> <a href="/tags/java并发编程实践/" style="font-size: 15.86px;">java并发编程实践</a> <a href="/tags/jdbc/" style="font-size: 10.34px;">jdbc</a> <a href="/tags/jpa/" style="font-size: 10px;">jpa</a> <a href="/tags/karatsuba/" style="font-size: 10px;">karatsuba</a> <a href="/tags/kasaraju/" style="font-size: 10px;">kasaraju</a> <a href="/tags/kd树/" style="font-size: 12.41px;">kd树</a> <a href="/tags/kmp/" style="font-size: 10px;">kmp</a> <a href="/tags/knn/" style="font-size: 10px;">knn</a> <a href="/tags/kruskal/" style="font-size: 10.34px;">kruskal</a> <a href="/tags/kth/" style="font-size: 10.34px;">kth</a> <a href="/tags/leetcode/" style="font-size: 13.1px;">leetcode</a> <a href="/tags/libreoj/" style="font-size: 10px;">libreoj</a> <a href="/tags/lightoj/" style="font-size: 12.07px;">lightoj</a> <a href="/tags/makedata/" style="font-size: 10px;">makedata</a> <a href="/tags/mapreduce/" style="font-size: 10px;">mapreduce</a> <a href="/tags/md数学公式对齐/" style="font-size: 10px;">md数学公式对齐</a> <a href="/tags/miller-rabin/" style="font-size: 10px;">miller-rabin</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/next-permutation/" style="font-size: 10px;">next_permutation</a> <a href="/tags/node/" style="font-size: 10px;">node</a> <a href="/tags/nth-element/" style="font-size: 10px;">nth_element</a> <a href="/tags/oj/" style="font-size: 19.66px;">oj</a> <a href="/tags/oracle/" style="font-size: 10px;">oracle</a> <a href="/tags/pair的用法/" style="font-size: 10px;">pair的用法</a> <a href="/tags/poj/" style="font-size: 19.31px;">poj</a> <a href="/tags/pollard-rho/" style="font-size: 10px;">pollard-rho</a> <a href="/tags/postgresql/" style="font-size: 10px;">postgresql</a> <a href="/tags/prim/" style="font-size: 11.03px;">prim</a> <a href="/tags/sap/" style="font-size: 11.03px;">sap</a> <a href="/tags/sbt/" style="font-size: 10px;">sbt</a> <a href="/tags/scc/" style="font-size: 11.03px;">scc</a> <a href="/tags/sdutoj/" style="font-size: 11.72px;">sdutoj</a> <a href="/tags/servlet/" style="font-size: 10px;">servlet</a> <a href="/tags/sjtuoj/" style="font-size: 10px;">sjtuoj</a> <a href="/tags/spfa/" style="font-size: 10.69px;">spfa</a> <a href="/tags/spoj/" style="font-size: 10px;">spoj</a> <a href="/tags/spring/" style="font-size: 12.07px;">spring</a> <a href="/tags/springboot/" style="font-size: 10.69px;">springboot</a> <a href="/tags/springmvc/" style="font-size: 10.34px;">springmvc</a> <a href="/tags/sql/" style="font-size: 10px;">sql</a> <a href="/tags/sscanf/" style="font-size: 10px;">sscanf</a> <a href="/tags/sstream/" style="font-size: 10.34px;">sstream</a> <a href="/tags/stringstream/" style="font-size: 10.34px;">stringstream</a> <a href="/tags/swagger/" style="font-size: 10px;">swagger</a> <a href="/tags/synchronized/" style="font-size: 10.34px;">synchronized</a> <a href="/tags/tarjan/" style="font-size: 11.38px;">tarjan</a> <a href="/tags/topK/" style="font-size: 10.34px;">topK</a> <a href="/tags/treap/" style="font-size: 10px;">treap</a> <a href="/tags/trie/" style="font-size: 12.07px;">trie</a> <a href="/tags/tsp/" style="font-size: 10px;">tsp</a> <a href="/tags/uoj/" style="font-size: 10px;">uoj</a> <a href="/tags/uva/" style="font-size: 12.41px;">uva</a> <a href="/tags/vector初始化容量/" style="font-size: 10px;">vector初始化容量</a> <a href="/tags/volatile/" style="font-size: 10.34px;">volatile</a> <a href="/tags/vue/" style="font-size: 10.69px;">vue</a> <a href="/tags/zoj/" style="font-size: 10.34px;">zoj</a> <a href="/tags/zzuli/" style="font-size: 10px;">zzuli</a> <a href="/tags/zzulioj/" style="font-size: 10px;">zzulioj</a> <a href="/tags/三分/" style="font-size: 10.34px;">三分</a> <a href="/tags/中位数/" style="font-size: 10px;">中位数</a> <a href="/tags/中国剩余定理/" style="font-size: 10px;">中国剩余定理</a> <a href="/tags/事务/" style="font-size: 11.38px;">事务</a> <a href="/tags/二分/" style="font-size: 10.69px;">二分</a> <a href="/tags/二分图/" style="font-size: 10px;">二分图</a> <a href="/tags/二分查找/" style="font-size: 10.34px;">二分查找</a> <a href="/tags/二分答案/" style="font-size: 12.07px;">二分答案</a> <a href="/tags/二叉树/" style="font-size: 10.34px;">二叉树</a> <a href="/tags/二进制状态压缩/" style="font-size: 10px;">二进制状态压缩</a> <a href="/tags/交叉染色/" style="font-size: 10px;">交叉染色</a> <a href="/tags/交叉染色法/" style="font-size: 10px;">交叉染色法</a> <a href="/tags/优先队列/" style="font-size: 14.48px;">优先队列</a> <a href="/tags/传递闭包/" style="font-size: 10px;">传递闭包</a> <a href="/tags/位图/" style="font-size: 10px;">位图</a> <a href="/tags/全排列/" style="font-size: 12.76px;">全排列</a> <a href="/tags/内存模型/" style="font-size: 10.34px;">内存模型</a> <a href="/tags/内部排序/" style="font-size: 10px;">内部排序</a> <a href="/tags/分块矩阵快速幂/" style="font-size: 10px;">分块矩阵快速幂</a> <a href="/tags/分支限界/" style="font-size: 11.03px;">分支限界</a> <a href="/tags/分治/" style="font-size: 10.69px;">分治</a> <a href="/tags/分解素因数/" style="font-size: 11.38px;">分解素因数</a> <a href="/tags/划分数/" style="font-size: 10.34px;">划分数</a> <a href="/tags/前端/" style="font-size: 11.38px;">前端</a> <a href="/tags/剑指offer/" style="font-size: 10px;">剑指offer</a> <a href="/tags/剪枝/" style="font-size: 10.69px;">剪枝</a> <a href="/tags/割点/" style="font-size: 11.38px;">割点</a> <a href="/tags/割边/" style="font-size: 11.03px;">割边</a> <a href="/tags/动态查找/" style="font-size: 10px;">动态查找</a> <a href="/tags/动态规划/" style="font-size: 11.72px;">动态规划</a> <a href="/tags/区间DP/" style="font-size: 10.34px;">区间DP</a> <a href="/tags/单向连通/" style="font-size: 10px;">单向连通</a> <a href="/tags/单纯形法/" style="font-size: 10.34px;">单纯形法</a> <a href="/tags/单调子序列/" style="font-size: 10.34px;">单调子序列</a> <a href="/tags/单调队列/" style="font-size: 10.34px;">单调队列</a> <a href="/tags/卡塔兰数/" style="font-size: 11.38px;">卡塔兰数</a> <a href="/tags/卡米切尔数/" style="font-size: 10px;">卡米切尔数</a> <a href="/tags/原生js/" style="font-size: 10px;">原生js</a> <a href="/tags/双向bfs/" style="font-size: 10px;">双向bfs</a> <a href="/tags/反向建图/" style="font-size: 10px;">反向建图</a> <a href="/tags/反转开关问题/" style="font-size: 10.34px;">反转开关问题</a> <a href="/tags/同步/" style="font-size: 10.34px;">同步</a> <a href="/tags/后台/" style="font-size: 10px;">后台</a> <a href="/tags/后端/" style="font-size: 18.62px;">后端</a> <a href="/tags/后端，数据库-mysql/" style="font-size: 10px;">后端，数据库, mysql</a> <a href="/tags/后缀树/" style="font-size: 10px;">后缀树</a> <a href="/tags/启发式搜索/" style="font-size: 10.34px;">启发式搜索</a> <a href="/tags/哈密顿回路/" style="font-size: 10px;">哈密顿回路</a> <a href="/tags/哈希/" style="font-size: 11.38px;">哈希</a> <a href="/tags/回归/" style="font-size: 10px;">回归</a> <a href="/tags/回文/" style="font-size: 10px;">回文</a> <a href="/tags/回溯/" style="font-size: 10px;">回溯</a> <a href="/tags/图/" style="font-size: 18.28px;">图</a> <a href="/tags/在线算法/" style="font-size: 10px;">在线算法</a> <a href="/tags/坐标离散化/" style="font-size: 10px;">坐标离散化</a> <a href="/tags/块/" style="font-size: 10px;">块</a> <a href="/tags/堆/" style="font-size: 10px;">堆</a> <a href="/tags/堆优化/" style="font-size: 10.69px;">堆优化</a> <a href="/tags/堆排/" style="font-size: 10.34px;">堆排</a> <a href="/tags/堆排序/" style="font-size: 10px;">堆排序</a> <a href="/tags/外部排序/" style="font-size: 10px;">外部排序</a> <a href="/tags/多源多汇/" style="font-size: 10px;">多源多汇</a> <a href="/tags/多重背包/" style="font-size: 11.03px;">多重背包</a> <a href="/tags/多重集组合数/" style="font-size: 10px;">多重集组合数</a> <a href="/tags/大数据/" style="font-size: 10.69px;">大数据</a> <a href="/tags/字典序最小/" style="font-size: 10px;">字典序最小</a> <a href="/tags/字符串/" style="font-size: 13.1px;">字符串</a> <a href="/tags/字符串匹配/" style="font-size: 10px;">字符串匹配</a> <a href="/tags/完全背包/" style="font-size: 10px;">完全背包</a> <a href="/tags/宽搜/" style="font-size: 10.34px;">宽搜</a> <a href="/tags/小程序/" style="font-size: 10px;">小程序</a> <a href="/tags/尺取法/" style="font-size: 10.34px;">尺取法</a> <a href="/tags/左式堆/" style="font-size: 10px;">左式堆</a> <a href="/tags/带括号带逗号的恶心输入/" style="font-size: 10px;">带括号带逗号的恶心输入</a> <a href="/tags/带权并查集/" style="font-size: 10px;">带权并查集</a> <a href="/tags/平方分割/" style="font-size: 10px;">平方分割</a> <a href="/tags/平衡查找树/" style="font-size: 10px;">平衡查找树</a> <a href="/tags/平面最近点对/" style="font-size: 11.03px;">平面最近点对</a> <a href="/tags/并发/" style="font-size: 16.9px;">并发</a> <a href="/tags/并查集/" style="font-size: 14.14px;">并查集</a> <a href="/tags/康托展开/" style="font-size: 11.38px;">康托展开</a> <a href="/tags/弹性碰撞/" style="font-size: 10.34px;">弹性碰撞</a> <a href="/tags/强连通/" style="font-size: 10.34px;">强连通</a> <a href="/tags/强连通分支/" style="font-size: 10.34px;">强连通分支</a> <a href="/tags/归并排序/" style="font-size: 10px;">归并排序</a> <a href="/tags/归并树/" style="font-size: 10px;">归并树</a> <a href="/tags/心语/" style="font-size: 10px;">心语</a> <a href="/tags/快排/" style="font-size: 10.69px;">快排</a> <a href="/tags/快速幂/" style="font-size: 13.1px;">快速幂</a> <a href="/tags/性能优化/" style="font-size: 10px;">性能优化</a> <a href="/tags/感悟/" style="font-size: 10px;">感悟</a> <a href="/tags/手工扩栈/" style="font-size: 10px;">手工扩栈</a> <a href="/tags/扩展KMP/" style="font-size: 10.69px;">扩展KMP</a> <a href="/tags/扩展欧几里得/" style="font-size: 10.69px;">扩展欧几里得</a> <a href="/tags/抓包/" style="font-size: 10px;">抓包</a> <a href="/tags/折半枚举/" style="font-size: 10px;">折半枚举</a> <a href="/tags/拆点/" style="font-size: 11.03px;">拆点</a> <a href="/tags/拓扑排序/" style="font-size: 12.76px;">拓扑排序</a> <a href="/tags/排序/" style="font-size: 16.21px;">排序</a> <a href="/tags/搜索/" style="font-size: 13.79px;">搜索</a> <a href="/tags/操作系统/" style="font-size: 11.03px;">操作系统</a> <a href="/tags/教材/" style="font-size: 18.97px;">教材</a> <a href="/tags/数学/" style="font-size: 15.52px;">数学</a> <a href="/tags/数据库/" style="font-size: 10px;">数据库</a> <a href="/tags/数组/" style="font-size: 10px;">数组</a> <a href="/tags/数论/" style="font-size: 12.07px;">数论</a> <a href="/tags/方差优化/" style="font-size: 10px;">方差优化</a> <a href="/tags/暴力/" style="font-size: 10px;">暴力</a> <a href="/tags/最大公约数/" style="font-size: 10px;">最大公约数</a> <a href="/tags/最大流/" style="font-size: 13.79px;">最大流</a> <a href="/tags/最大流算法的优化/" style="font-size: 10px;">最大流算法的优化</a> <a href="/tags/最大流算法重弧和自环和反向平行弧不会影响算法的正确性而只会影响效率/" style="font-size: 10px;">最大流算法重弧和自环和反向平行弧不会影响算法的正确性而只会影响效率</a> <a href="/tags/最大生成树/" style="font-size: 10.34px;">最大生成树</a> <a href="/tags/最小正整数解/" style="font-size: 10.34px;">最小正整数解</a> <a href="/tags/最小生成树/" style="font-size: 11.38px;">最小生成树</a> <a href="/tags/最短路/" style="font-size: 13.1px;">最短路</a> <a href="/tags/最短路径/" style="font-size: 12.07px;">最短路径</a> <a href="/tags/最长回文子串/" style="font-size: 10px;">最长回文子串</a> <a href="/tags/有向图/" style="font-size: 10px;">有向图</a> <a href="/tags/机器学习/" style="font-size: 10px;">机器学习</a> <a href="/tags/杂/" style="font-size: 10px;">杂</a> <a href="/tags/板子/" style="font-size: 10px;">板子</a> <a href="/tags/查找/" style="font-size: 10px;">查找</a> <a href="/tags/查找树/" style="font-size: 12.76px;">查找树</a> <a href="/tags/栈/" style="font-size: 13.45px;">栈</a> <a href="/tags/树/" style="font-size: 17.59px;">树</a> <a href="/tags/树堆/" style="font-size: 10px;">树堆</a> <a href="/tags/树形dp/" style="font-size: 10.34px;">树形dp</a> <a href="/tags/树排/" style="font-size: 10px;">树排</a> <a href="/tags/树状数组/" style="font-size: 11.38px;">树状数组</a> <a href="/tags/树的直径/" style="font-size: 10.69px;">树的直径</a> <a href="/tags/桶排序/" style="font-size: 10px;">桶排序</a> <a href="/tags/模块化/" style="font-size: 10px;">模块化</a> <a href="/tags/模拟/" style="font-size: 12.07px;">模拟</a> <a href="/tags/模拟退火/" style="font-size: 11.03px;">模拟退火</a> <a href="/tags/模板/" style="font-size: 12.41px;">模板</a> <a href="/tags/次短路/" style="font-size: 10px;">次短路</a> <a href="/tags/欧几里得/" style="font-size: 10.34px;">欧几里得</a> <a href="/tags/欧拉函数/" style="font-size: 10.34px;">欧拉函数</a> <a href="/tags/欧拉回路/" style="font-size: 12.76px;">欧拉回路</a> <a href="/tags/欧拉环游/" style="font-size: 10px;">欧拉环游</a> <a href="/tags/欧拉环路/" style="font-size: 10px;">欧拉环路</a> <a href="/tags/死锁/" style="font-size: 10px;">死锁</a> <a href="/tags/泛洪/" style="font-size: 10px;">泛洪</a> <a href="/tags/洛谷/" style="font-size: 12.41px;">洛谷</a> <a href="/tags/洪特规则/" style="font-size: 10px;">洪特规则</a> <a href="/tags/浮点数二分答案/" style="font-size: 10px;">浮点数二分答案</a> <a href="/tags/深搜/" style="font-size: 11.38px;">深搜</a> <a href="/tags/源码/" style="font-size: 17.93px;">源码</a> <a href="/tags/源码分析/" style="font-size: 11.03px;">源码分析</a> <a href="/tags/滚动数组/" style="font-size: 10px;">滚动数组</a> <a href="/tags/版本控制/" style="font-size: 10px;">版本控制</a> <a href="/tags/牛客网/" style="font-size: 11.03px;">牛客网</a> <a href="/tags/牛顿迭代法/" style="font-size: 10px;">牛顿迭代法</a> <a href="/tags/状态压缩/" style="font-size: 10.69px;">状态压缩</a> <a href="/tags/状态压缩DP/" style="font-size: 10px;">状态压缩DP</a> <a href="/tags/生成树/" style="font-size: 10.34px;">生成树</a> <a href="/tags/百练/" style="font-size: 10.69px;">百练</a> <a href="/tags/矩阵快速幂/" style="font-size: 11.03px;">矩阵快速幂</a> <a href="/tags/离散化/" style="font-size: 11.03px;">离散化</a> <a href="/tags/空间复杂度优化/" style="font-size: 10px;">空间复杂度优化</a> <a href="/tags/筛法/" style="font-size: 11.72px;">筛法</a> <a href="/tags/简历/" style="font-size: 10px;">简历</a> <a href="/tags/算法/" style="font-size: 20px;">算法</a> <a href="/tags/精确匹配/" style="font-size: 10px;">精确匹配</a> <a href="/tags/精确覆盖/" style="font-size: 10px;">精确覆盖</a> <a href="/tags/素数/" style="font-size: 10px;">素数</a> <a href="/tags/素数测试/" style="font-size: 10.69px;">素数测试</a> <a href="/tags/约瑟夫环/" style="font-size: 10px;">约瑟夫环</a> <a href="/tags/线上问题/" style="font-size: 10px;">线上问题</a> <a href="/tags/线性同余方程/" style="font-size: 10px;">线性同余方程</a> <a href="/tags/线性筛/" style="font-size: 10px;">线性筛</a> <a href="/tags/线性规划/" style="font-size: 10.34px;">线性规划</a> <a href="/tags/线段树/" style="font-size: 13.45px;">线段树</a> <a href="/tags/组件化/" style="font-size: 10px;">组件化</a> <a href="/tags/编译原理/" style="font-size: 13.79px;">编译原理</a> <a href="/tags/缩点/" style="font-size: 11.03px;">缩点</a> <a href="/tags/缩点重构DAG/" style="font-size: 10.34px;">缩点重构DAG</a> <a href="/tags/网络协议/" style="font-size: 10px;">网络协议</a> <a href="/tags/网络流/" style="font-size: 12.07px;">网络流</a> <a href="/tags/网络流建图/" style="font-size: 10px;">网络流建图</a> <a href="/tags/背包/" style="font-size: 14.14px;">背包</a> <a href="/tags/胜者树/" style="font-size: 10px;">胜者树</a> <a href="/tags/自己动手用java写编译器/" style="font-size: 13.79px;">自己动手用java写编译器</a> <a href="/tags/菜鸟教材/" style="font-size: 10.69px;">菜鸟教材</a> <a href="/tags/蓝桥杯/" style="font-size: 10px;">蓝桥杯</a> <a href="/tags/计算几何/" style="font-size: 12.76px;">计算几何</a> <a href="/tags/记忆化搜索/" style="font-size: 10.69px;">记忆化搜索</a> <a href="/tags/设计模式/" style="font-size: 10.69px;">设计模式</a> <a href="/tags/词典/" style="font-size: 10px;">词典</a> <a href="/tags/负权环/" style="font-size: 10.34px;">负权环</a> <a href="/tags/败者树/" style="font-size: 10px;">败者树</a> <a href="/tags/贪心/" style="font-size: 15.52px;">贪心</a> <a href="/tags/轮播图/" style="font-size: 10px;">轮播图</a> <a href="/tags/输出方案/" style="font-size: 10px;">输出方案</a> <a href="/tags/边bcc/" style="font-size: 10.69px;">边bcc</a> <a href="/tags/连通/" style="font-size: 11.03px;">连通</a> <a href="/tags/连通分支/" style="font-size: 10.34px;">连通分支</a> <a href="/tags/连通性/" style="font-size: 11.38px;">连通性</a> <a href="/tags/逆元/" style="font-size: 10px;">逆元</a> <a href="/tags/逆序数/" style="font-size: 10.34px;">逆序数</a> <a href="/tags/递归/" style="font-size: 11.38px;">递归</a> <a href="/tags/递归转栈/" style="font-size: 10px;">递归转栈</a> <a href="/tags/遍历/" style="font-size: 10px;">遍历</a> <a href="/tags/邻接多重表/" style="font-size: 10.69px;">邻接多重表</a> <a href="/tags/邻接链表法/" style="font-size: 10px;">邻接链表法</a> <a href="/tags/重复覆盖/" style="font-size: 10px;">重复覆盖</a> <a href="/tags/链表/" style="font-size: 11.38px;">链表</a> <a href="/tags/锁/" style="font-size: 10.69px;">锁</a> <a href="/tags/队列/" style="font-size: 11.38px;">队列</a> <a href="/tags/集合/" style="font-size: 10px;">集合</a> <a href="/tags/静态查找树/" style="font-size: 10.34px;">静态查找树</a> <a href="/tags/非递归/" style="font-size: 10px;">非递归</a> <a href="/tags/面试/" style="font-size: 14.83px;">面试</a> <a href="/tags/马踏棋盘/" style="font-size: 10px;">马踏棋盘</a> <a href="/tags/高精度/" style="font-size: 13.45px;">高精度</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/10/02/洛谷-P1880-NOI1995-石子合并-区间DP/">洛谷 P1880 [NOI1995]石子合并 区间DP</a>
          </li>
        
          <li>
            <a href="/2019/10/02/sdnuoj-1045-石子合并1-DP的平行四边形优化/">sdnuoj 1045 石子合并1 DP的平行四边形优化</a>
          </li>
        
          <li>
            <a href="/2019/10/02/poj-1738-An-old-Stone-Game-GarsiaWachs算法/">poj 1738 An old Stone Game GarsiaWachs算法</a>
          </li>
        
          <li>
            <a href="/2019/10/02/poj-1160-Post-Office-DP的平行四边形优化/">poj 1160 Post Office DP的平行四边形优化</a>
          </li>
        
          <li>
            <a href="/2019/10/01/面试-打印输出全部出栈次序/">面试 打印输出全部出栈次序</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget tag">
    <h3 class="title">友情链接</h3>
      <ul class="entry">
        
          <li class="link"><a href="https://e99net.github.io/">99°</a></li>
        
      </ul>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="https://cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>